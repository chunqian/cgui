{\rtf\ansi\deff0\widowctrl \f0\fs20 
{\colortbl;\red0\green0\blue0;\red255\green0\blue0;\red0\green255\blue0;\red0\green0\blue255;}
{\fonttbl{\f0\froman\fcharset0\fprq2 Times New Roman;}
{\f1\fmodern\fcharset0\fprq1 Courier New;}
{\f2\froman\fcharset2\fprq2 Symbol;}}
{\stylesheet {\widctlpar \f0\fs20 \snext0 Normal;}
{\s1\widctlpar \f1\fs18 \sbasedon0\snext1 Quotation;}
{\s2\widctlpar \f0\fs48\sa600\pagebb\keepn\ul \sbasedon0\snext2 Heading 1;}
{\s3\widctlpar \f0\fs24\sb200\keepn\sa200\b \sbasedon0\snext3 Heading 2;}
{\s4\widctlpar \f0\fs20\tqc\tx4153\tqr\tx8306 \sbasedon0\snext4 Header;}
{\s5\widctlpar \f0\fs24\tqr\tldot\tx8640 \sbasedon0\snext0 TOC 1;}
{\s6\widctlpar \f0\fs20\tqr\tldot\tx8640 \sbasedon0\snext0 Index 1;}}
{\header \pard\plain \s4 \f0\fs20\tqc\tx4153\tqr\tx8306 \pvpara\phmrg\posxr\posy0 page {\field{\*\fldinst PAGE}{\fldrslt 2}}
\par \pard \s4\ri360 \f0\fs20\tqc\tx4153\tqr\tx8306 {\i CGUI  - a C-based GUI} \pard}
#@multiplefiles 
\par {\qc \par}\par {\qc {\b \par A C Graphical User Interface [add on to Allegro] by Christer Sandberg\par}\par}
\par {\qc \par \par \par Email: rya.christer@gmail.com\par}
\par {\qc \par \par Homepage: http://cgui.sourceforge.net/\par}
\par {\qc {\b \par \par The Manual of CGUI 2.0.5 
\par {\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Contents}Contents\par }
\par 
{\field{\*\fldinst TOC \\t "Heading 1" }{\fldrslt {\b\i\ul\fs24\cf2 Update this field to generate the table of contents.}}}
\par {\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Using CGUI}Using CGUI\par }
When you want to compile and link your own program that uses CGUI you need 
to know the following 
\par {\li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 To satisfy the compiler you need to #include <cgui.h> in the top of 
each file that uses a function from the CGUI library. 
\par \pard \li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 Before calling any CGUI function you must have initialised CGUI once. 
\par \pard \li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 To satisfy the linker you need to tell the linker that you want to use 
the Allegro library and the CGUI library. You also need to tell if you 
want to link dynamic or static, and the choice you do need of course the 
corresponding libraries to be installed.\par \pard \li400 
How to tell the linker this, may differ depending on which compiler and 
development environment you use. You are supposed to be familiar with 
the platform you use. Here are mentioned only some possibilities: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  If you use gcc (or djgpp or mingw32) and link on the command line, 
link with '-lcgui -lalleg'. It is in this case important that you 
specify the libraries in that order. If you instead want to use 
the debug version of the libraray, then link with '-lcguid' 
instead of '-lcgui'. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  If you use RHIDE, go to the menu Options/Libraries and fill 
in 'cgui'. It is important that 'cgui' is before 'alleg'. Don't 
forget to check the box to the left of the library. You have to 
replace 'cgui' with 'cguid' to include debugging information. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  If you use MSVC version 6.0 the integrated environment and have 
a "Win32 Application" project, the setting may possibly be done 
the following way. "Project" menu -> "Settings" opens a 
dialogue. Select the "Link" tab. Chose "Category" to "General". 
Add the text "alleg.lib cgui.lib" at end of "Object/Library 
modules" separated with a space. 
\par}\pard \li400 \pard \li400 \pard \li400 \pard \li400 \par \par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 The dialogues in CGUI may want to save and restore some user settings in 
the default allegro.cfg file. If that file is not present the dialoues 
will work anyway, only that the changes will never be stored. You don't 
need to type any initial data into the config file.\par \pard \li400 
There is a minor allegro.cfg in the examples directory of CGUI. You will 
find another one in your installation of Allegro. It is supposed to be 
located in the directory of your program executable. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 To make the keyboard work as you are used with (country specific 
keyboard), then you need to have the allegro.cfg present, and you need 
to type in it the prefered keyboard. See comments in the file. 
\par \pard \li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 If you need to use some of the dialogs in CGUI you will find that it uses 
the english language. Actually there is a possibilty to chose any other 
language. This is also done in the allegro.cfg file. Currently there 
are only two choices, swedish and english. If you want to translate to 
your favourite language, just contact me for instructions about how to do. 
\par \pard \li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 The default font used int CGUI may not satisfy the requirements of your 
language. If so, just make your own font using Allegro, load it using 
Allegro, and tell CGUI to use it (see section Fonts). 
\par \pard \li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 The steps needed to build a simple dialogue is the following: 
\par {\li800 \pard \li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 Create a dialogue window (by a call to `MkDialogue'). This is still 
not visible. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 Put some objects into that window (e.g.  `AddButton',  `AddEditBox' etc). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 Make it all visible by calling `DisplayWin'. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 Call `ProcessEvents', which will start scanning keyboard and mouse 
for events. If you e.g. have a Close button and the user klicks that 
button, you funcation (the one passed to  `AddButton') will be called 
back. Typically it should call `CloseWin' to close the window, and 
`StopProcessEvents' to force `ProcessEvents' to stop (and the 
execution will continue at the code line after the call to 
`ProcessEvents'). 
\par}\pard \li400 \pard \li400 \pard \li400 \pard \li400 \pard \li400 \par \par}\par Fundamental in CGUI is the event driven approach. This means that your 
program doesn't need to check for certain operator actions like mouse 
clicks and key presses. Instead you must write functions that will be 
called by CGUI when those events occure. Therefore you must inform CGUI 
which function to call. You do that by passing a pointer to your 
function when creating any object that needs such a callback. 
Your callback function may do whatever it likes, e.g. start a new 
dialogue (i.e. put another window above the current) or close the 
current window or exit (by calling exit) or call `StopProcessEvents', etc. 
\par \par \par {\b A few word to those that are not used with function pointers:\par}
Maybe you find the declaration of functions in CGUI a bit messy because 
of the callback parameter, but don't worry - when writing your code for 
the actual call you will find it quite ok. \par 
The C-code in the callback may look like the code of any of the functions 
you have written before, there are no special requirements except that 
the declaration (the function head) must match that of the function 
pointer - so there will be a void* pointer involved in most cases.\par 
Example: 
\par {\s1 \f1\fs18 
\par    ...
\par    my_type *my_data;
\par    ...
\par    AddButton(DOWNLEFT, "OK", my_okfun, my_data);
\par    ...
\par    void my_okfun(void *data)
\par    \{
\par       my_type *my_data = data;
\par       /* Do whatever you need */
\par    \}
\par    \par}The declaration of the function passed to AddButton must be like above 
(i.e. taking a single parameter of type void*). To use the data you need 
to copy the pointer to one of a type that is not void* like above. That 
type must of course be the one of the last parameter passed to AddButton.\par 
When passing your function pointer and data pointer lika this, e.g. 
\par {\s1 \f1\fs18 
\par    AddButton(DOWNLEFT, "Label", fptr, dataptr);
\par    \par}You should think like this:\par 
When the button is pressed by the user, the call {\b fptr(dataptr);\par}
\par will be done, and you must write the code of fptr to match that. 
\par \par \par Lots of important functions in CGUI needs function pointer and void* 
pointers, and they should all be handled similarly. 
\par \par \par There are also several examples in the directory "cgui/examples" which 
can be useful to look at. 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v InitCgui}InitCgui(int w, int h, int color_depth);\par }
{\li400 This function initializes CGUI. This includes setting a graphic mode 
as specified by the parameters. CGUI will also take over the keyboard 
and mouse, and this is done by the initialization function. A desktop 
will be created automatically. 
\par \par \par There are some alternative initialization functions: InitCguiLoadMode, 
InitCguiFullscreenMode, InitCguiWindowedMode and InitCguiKeepCurrent 
that differs only in how the graphics is initialized. Se the sections 
for these if you want to know details.\par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  w,h: The size of the desktop. In case of full screen mode this is also 
the screen resolution, else the (inner) size of the window. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  color_depth: The colour depth to be used, expressed in bits, see 
Allegro's `set_color_depth' for info about color dephts. 8 bits color 
depth implies palette mode. If you don't know about palettes you should 
avoid choosing 8 bit mode. If you do know about it please help yourself 
in sorting out how to use it. CGUI does not support it in any way - it 
will use makecol() to find the color indecies that best fits the color 
specified in the config file. The standard palette on a PC will most 
likely not be suitable for the default one. 
\par}\pard \li400 \pard \li400 \par Simple initialisation: just call the initialization function at 
program start (i.e. without initializing any part of Allegro, CGUI will 
do that for you). 
\par \par \par Whenever CGUI fails to set a graphics mode (this applies also to the 
alternative initialization functions) it will do the following: 
The first attempt is to try another colour depth. If the requested colour 
depth was 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  8 no more try 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  15 it will try 16 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  16 it will try 15 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  24 it will try in order 32, 16, 15 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  32 it will try in order 24, 16, 15 
\par}\pard \li400 \pard \li400 \pard \li400 \pard \li400 \pard \li400 \par If the above fails, it will try with a lower pixel resolution and the 
same sequence as above including the requested colour depth. This will be 
repeared until an accepted screen mode was found or there are only modes 
using 8 bits colour depth left (in which case it will try all resolutions 
from 640x480 and less in 8 bpp, and if still no one is accepted it will 
terminate the program by a call to exit).\par 
You can do subsequent calls to `InitCgui' to change the the screen 
mode (resolution and/or colour depth). Some CGUI-objects needs to be 
notified about the change, so to handle a screen mode change properly 
you should use this method instead of setting it directly with Allegro's 
set_gfx_mode() (if you still prefere the latter way you should call 
InitCgui afterwards). 
Returns always non-0 (does never fail). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v InitCguiLoadMode}InitCguiLoadMode(void)\par }
{\li400 Will look for a full screen mode setting in the current config file. 
\par {\s1 \f1\fs18 
\par    [cgui:screen-res]
\par    Width = 1024
\par    Height = 768
\par    Colour_depth = 15
\par    \par}The above numbers are a examples, you can preset these values to whateever 
you like. If you make CGUI's screen mode selector available for the user 
of your program that dialogue will uppdate the values. 
If no settings were found, then 1024x768x32 will be used. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v InitCguiFullscreenMode}InitCguiFullscreenMode(void)\par }
{\li400 Will try to pick the current screen mode from the system and then 
use these when trying to set a full screen mode. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v InitCguiWindowedMode}InitCguiWindowedMode(void)\par }
{\li400 Will try to keep the current screen mode of a windowed environment and 
try to set the CGUI screen to windowed mode, with the same colour depth, 
and a window size equal to the next smaller possible resolution. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v InitCguiKeepCurrent}InitCguiKeepCurrent(void)\par }
{\li400 Will no set the grapics mode at all. This requires the graphic to be 
initialized before calling InitCguiKeepCurrent (i.e. call set_gfx_mode 
first). 
\par \par \par In paletted mode CGUI will make no changes to the palette. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v DeInitCgui}DeInitCgui(void);\par }
{\li400 Closes all windows, removes the event queue and frees all data 
allocated by CGUI. 
\par \par \par DeInitCgui will be automatically called at exit, so normally you don't 
need to call it yourself. 
\par \par \par NOTE! It is important that you call DeInitCgui NOT from within any 
callback from CGUI, i.e. the call must be after the event processing 
has terminated (immediately after the call to ProcessEvents()). 
\par \par \par If graphics were initialized before the first call to InitCgui() then the 
screen content will be restored to what is was by that time, but the 
screen mode will not. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v CguiUseUTF8}CguiUseUTF8(void);\par }
{\li400 By default CGUI assume strings to be in 8 bit ascii. To change this and 
force handling UTF-8 encoding of unicode, you can call this function. 
You should call it before calling CguiInit(). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v cgui_ver}cgui_ver, cgui_rev, cgui_minor_rev, cgui_release_date;\par }
{\li400 \par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v HookExit}HookExit(int id, void (*ExitFun)(void *data), void *data);\par }
{\li400 This function installs the callback function `ExitFun'. This is a pointer 
to a function written by you. It will be called by CGUI when the object 
`id' is destroyed, and it will be passed the pointer `data'.\par 
If `id' refers to an object that has an "action-callback", like e.g. 
a button that has a call-back that will be called when the button is 
clicked, and such a function destroys the object `id' then `ExitFun' 
will be called when the "action-callback" is finished. To be more precise, 
`ExitFun' will be pushed on to the event queue. 
Installing an `ExitFun' may be useful if you want to free some memory 
allocated for e.g. a dialog, and wants a somple way to catch all 
possibilities of its closing.\par 
Returns 1 if id referes to an existing object, otherwise 0. 
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Windows}Windows\par }
Windows are areas that are visible on the screen and they serve as 
containers for objects. 
Windows will be placed at a position decided by the windowing system 
itself - it will try to centre them around the current cursor position. 
Windows can by default be moved with the mouse (by gripping the window 
header). 
There is always one window that is "in focus" i.e. that receives mouse 
commands and keyboard commands. If the same hot key is defined in several 
windows, the event of pressing that key will go to the focused window. 
So hot keys defined only in windows that are not in focus will be ignored. 
Hot keys may however be defined globally, and these will be handled even 
no matter which window is in focus. By default windows works like a 
stack: opening a new window makes that one be the active one displayed 
on top of the others. Closing a window lets the previous one be the 
active (top) window. There are several ways to override this, see 
MkDialogue for details. 
\par \par About requesters: This is a special type of windows, that wait until the 
user answers, i.e. you can use it without the "event driven" style 
of the code, but rather like the classical linear programming like 
when using scanf, getchar etc. 
You should however know that the event processing is still running while 
your function is waiting for the requester to return. So if other events 
like serial port, time-events etc. occur, these will be put into the 
event queue and will be processed in proper order while the requester 
is up. Processing these events can, if needed, open new windows and 
requesters without any problem. 
\par \par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v MkDialogue}MkDialogue(int width, int height, const char *title, int options);\par }
{\li400 Creates a new window. The window is however not completed (and not 
visible) until you call `DisplayWin'. In between you should add some 
objects to make it meaningful. \par 
Windows can be closed by `CloseWin'.\par 
The created window will be the child of the window that is in focus when 
calling `MkDialogue'. The new window will automatically be set in focus 
when it is created. It will also be set to be the "operating window" 
(i.e. the one into which objects will be put when created). \par 
In case you need to create multiple windows there are some window 
behaviour that needs to be discussed: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  How a window is displayed relative to other windows (which 
properties and states forces a window to be displayed on top of 
other). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  Window "focus". Which properties and states makes it possible for 
the user to alter the window beeing in focus. (Focus means that the 
window receives keyboard and mouse events. The focus is normally 
indicated to the user with some kind of highlighting). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  The life of a window. Since the meaning of one window may depend on 
another window's existance, there may also be need for 
"navel-strings" between windows (child - parent relation). 
\par}\pard \li400 \pard \li400 \pard \li400 \par In CGUI windows are arranged in a tree relation, where there is a virtual 
root and the the desktop (created by `InitCgui') is tha child of that. 
So if the first window you create has default settings it will be the 
child of the desktop. 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  The existense of at least one modal (non-floating) child, implies 
that a window can not get the focus. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  A child is unconditionally displayed on top of its parent. This 
means that even if the parent is in focus, the child will be on top. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  A floating window being in focus will be displayed on top of all 
its floating sisters (and all siblings of these). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  A non-floating window beeing in focus will be displayed on top of 
all its non-floating sisters (and all siblings of these). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  A floating window will at any time be displayed on top of all 
its non-floating sisters (and all siblings of these). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  A child will always die when its parent dies. 
\par}\pard \li400 \pard \li400 \pard \li400 \pard \li400 \pard \li400 \pard \li400 \par The properties that acomplishes the above behavior in CGUI are controlled 
by some optional flags listed below. \par 
When using which? 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  The simple (and probably most common) usage is the 
deafault (i.e. a modal child), requireing that the user closes the 
latest created window and thereafter finds the focus being on the 
parent. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  The "floating" property of a child may be useful e.g. if you want to 
create tool-palette window(s). The main window will be accessed at 
any time (i.e. the user can make it in focus by a mouse click), 
giving the ability to alter between picking tools from the 
tool-palette and work with stuff in the main window (including 
creating other palettes). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  The "sister" property may be useful e.g. to 
\par {\li1200 \pard \li1200 \pard \li1200 \pard \li1200 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  create a "globally floating" window to display the progress 
or state of some work in the background. It may also be useful 
for some kind of tool-palettes that one want to be available in 
all windows. This can be achieved by making it a sister to the 
desktop (floating or non-floating) or as the sister to the 
first "main" window (floating). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  create a group of non-floating windows, the focus possible to 
alter between them but can not move to the parent. 
\par}\pard \li800 \pard \li800 \pard \li800 \par \par}\par By default the window will be a child and a child is by default "modal", 
(non-floating). \par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  width, height: specifies the dimensions of the window. These 
values may be replaced by the ADAPTIVE command which will 
make the window adapt its size to be large enough to show all its 
objects. It may also be replaced by the FILLSCREEN command which 
simply sets the size to the current desktop size. If the desktop size 
is later on changed because the screen mode is changed by ScrMode, 
then all windows will automatically be redrawn, and a FILLSCREEN 
window will again take its size from the desktop dimensions. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  title: this is any text that will be displayed in the top bar of 
the window, e.g. to explain the purpose of the window to the user. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  options: if you don't need any of the options listed below, then 
just pass 0. Currently available options are listed below and can 
be combined with logical or. 
\par {\li1200 \pard \li1200 \pard \li1200 \pard \li1200 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  W_FLOATING: The opened window will be a floating window. This means 
that it will 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  W_SIBLING: The opened window will be the sister of the currently 
focused one. W_FLOATING and W_SIBLING can be combined. To mix 
non-floating and floating sisters is allowed but not always 
meaningful. The behaviour will be as stated above. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  W_NOMOVE: By default, windows allows the user to drag and drop 
them on the screen. This behaviour will be disabled by the 
flag W_NOMOVE. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  W_TOP: The vertical position will be at the top of the screen. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  W_BOTTOM: The vertical position will be at the bottom of the screen. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  W_LEFT: The horizontal position will be at the left side of the 
screen. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  W_RIGHT: The horizontal position will be at the right side of the 
screen. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  W_CENTRE_H: The horizontal position will be in the centre of the 
screen. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  W_CENTRE_V: The vertical position will be in the centre of the 
screen. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  W_CENTRE: The horizontal and vertical position will be in the centre 
of the screen. 
\par}\pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \par If no position option is specified the window will be positioned 
centered around the current mouse position.\par 
If only one of the vertical and horizontal positions is specified by 
the above option flags then the other will be set to 0.\par 
In addition to the above special position options, a window can be 
placed at an arbitrary position, see `SetWindowPosition'. 
\par}\par Return value: an id (in the same domain as objects). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v DisplayWin}DisplayWin(void);\par }
{\li400 `DisplayWin' must be called to complete a window and to make it visible. 
When adding various object into an opened window, these objects can not 
be completed immediately (e.g. their sizes and positions can in general 
not be computed until all of them are there). 
`DisplayWin' will do this completion, and also draw the objects onto the 
screen.\par 
`DisplayWin' may also be called later on to make all its object 
refreshed. Such a repeated call will also re-build the window, which 
is necessary if you remove or add objects to the window after the first 
call to `DisplayWin'.\par 
The window that will be affected is the one in focus. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v CloseWin}CloseWin(void *dummy);\par }
{\li400 Closes an open window. The parameter will not be used, it's there just 
to conform to the standard event-handler form - just pass a 
NULL-pointer. \par 
The window that will be affected is the one in focus.\par 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v SetWindowPosition}SetWindowPosition(int x, int y);\par }
{\li400 By default a window will be opened at a position that is assumed to be 
convenient for the user (se `MkDialogue' for details). This automatic 
behaviour can be overridden by calling `SetWindowPosition' with the 
desired position (upper x,y is the upper left corner of the window) after 
`MkDialogue' but before `DisplayWin'. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v DesktopImage}DesktopImage(BITMAP *bmp);\par }
{\li400 Sets the desktop image (the screen background).\par 
If bmp refers to the screen, then a copy of it will created. (This 
memory will be properly released when CGUI terminates.) If bmp is a 
memory bitmap, this function will just take a copy of the pointer, so it 
is your responsibility to keep it as long as CGUI is alive, and then do 
destroy_bitmap(bmp).\par 
If the size of the bitmap doesn't fit to the current size of the screen, 
then the following will be done: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 If bitmap is larger: it will be scaled to the size of screen. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 If bitmap is smaller: it will be repeatedly blitted to fill screen 
allowing you to draw patterns. 
\par}\pard \li400 \pard \li400 \par The desktop is not updated until  `Refresh' is called. Use ID_DESKTOP 
for `id' when calling `Refresh'. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v Request}Request(const char *title, int options, int width, const char *format, ...)\par }
{\li400 Opens a requester window of the same type as 'Req', but here you can specify 
the width of the text and also pass a format string of 'printf' type together 
with the necessary variable arguments.\par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  title: as for `Req'. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  options: the position codes as described under MkDialogue 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  width: The width of the requester. A value of 0 will give the default 
size (the same as for `Req') 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  format: as for `Req' but in addition it can contain format info like 
in the format string to the `*printf' functions. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  ...: Additional parameters corresponding to the format specifiaction 
(i.e. like the `*printf' functions). 
\par}\pard \li400 \pard \li400 \pard \li400 \pard \li400 \pard \li400 \par Return value: as for `Req'. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v Req}Req(const char *title, const char *format);\par }
{\li400 A window for prompting the user for a simple question or givin some brief 
information in a simple way.\par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  title: The text that will be displayed in the title bar of the requester 
window. If you don't need a title, then pass the empty string (""). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  format: This is a string containing some special info to create the 
buttons and their layout. 
\par {\li1200 \pard \li1200 \pard \li1200 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  Any info-text you want to be displayed, followed by: 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  At least one push-button label. Each label must be separated from 
the previous one (or the info-text) with the '|'-character. Each 
button label may optionally contain any optional characters that a 
labels in general can contain. 
\par}\pard \li800 \pard \li800 \pard \li800 \par \par}\par In opposit to other windows functions, this one will wait until the user 
has clicked one of the buttons. Before it returns it will close itself, 
so don't do that.\par 
Example of simple usage: 
\par {\s1 \f1\fs18 
\par  switch (Req("Operation request",
\par             "Do you really want to do this?|~Yes|~No|Confirm_each ste~p"))\{
\par  case 0:
\par     do_it();
\par     break;
\par  case 1:
\par     return;
\par  case 2:
\par     confirm();
\par  \}
\par  \par}Return value: The push-button number that the user selected. 0 is the 
first button in format string, 1 is the next etc. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v RedrawScreen}RedrawScreen(void);\par }
{\li400 Redraws the entire screen. All windows that are at least partly visible 
on the screen will be redrawn. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v GetWinInfo}GetWinInfo(int id, int *x, int *y, int *width, int *height);\par }
{\li400 Returns the coordinates and size of the specified window. The results 
will be given in screen coordiantes (with (0, 0) in upper left corner). 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v CurrentWindow}CurrentWindow(void);\par }
{\li400 Returns the id number for the current operating window. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v SetOperatingWindow}SetOperatingWindow(int winid);\par }
{\li400 Sets a new window to be the the "operating window". Most functions 
that operates on objects require an id-key for reference. For your 
conveniance that is not necessary when creating new objects, they will 
be put into the most recently created container in the most recently 
created window. That is the "operating window". 
Normally the operating window is the same as the one in focus. 
Occasionally you may later on want to add some objects to a window that 
is not in focus. Then you must use `SetOperatingWindow' (and maybe also 
SelectContainer) before adding the objects. Just use the id-key returned 
when the window was created, and pass it to SetOperatingWindow.\par 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v MkProgressWindow}MkProgressWindow(const char *wlabel, const char *blabel, int w);\par }
{\li400 A simple progress-bar window containing a progress bar and a status 
field. \par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  wlabel - A pointer to a string which will be used as informational 
text in the window header. Pass an empty string if not needed. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  blabel - A pointer to a string which will be used as the label 
on a button that gives the user the opportunity to close the window. 
Pass an empty string if you don't want the button to be there. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  w - The width of the progress-bar. 
\par}\pard \li400 \pard \li400 \pard \li400 \par Return value is the id of the window. This can be used to update 
the current value by calling UpdateProgressValue'. 
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Objects}Objects\par }
\par \par Window objects may be of different types. Below is a list of the "simple" 
types. You can find contaners and menus in other sections. 
\par \par A window object is an object that is in a window. It is assigned a 
rectangular area within this window, and it has the full responsibility 
for that area. This responsibility includes: 
\par {\li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  Drawing on it - if it does not draw anything, the content of that 
area is undefined. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  Receiving messages from the mouse. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  Receiving messages from the keyboard. 
\par}\pard \li0 \pard \li0 \pard \li0 \par These tasks are performed automatically - you don't need to bother about 
{\b _how_\par}\par  to do it, but maybe you need to know that it works in this 
way (in fact an object also has some more tasks that we don't talk about 
for the moment). 
\par \par As a consequence of the above, there will be problems if simple objects 
like push buttons etc., overlap each other (which of them should draw and 
which of them should receive mouse messages?). To make it easy for you 
to avoid overlapping, you can use direction commands rather than 
specify the coordinates of the object; see the 
"Direction commands for object positioning" section. 
\par \par How do you know the width and height of an object? In fact you normally 
don't need to bother about this in CGUI - the objects will adapt their 
size to be large enough. For example: 
\par {\li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 A text labelled check box will be as wide as is needed to show its 
label and check mark. The height will be the height necessary for the 
text. 
\par \pard \li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 A push-button with an image and a text label will be large enough to 
show both the label and image. 
\par}\pard \li0 \par Some types of objects need explicit coordinates (e.g. the width field 
of edit boxes), see the specific object type for more information. 
\par \par Also note that to create a nice interface you may use the container 
facility to create subgroups of objects. Containers are discribed in 
another section. 
\par \par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v AddButton}AddButton(int x, int y, const char *label, void (*CallBack) (void *data), void *data);\par }
{\li400 This function creates the standard type of push button. \par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  x,y: The position of the object (or you can use "direction commands"). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  label: the label text that will be displayed on top of the button, 
see general text label info for details. The text labels for buttons 
may contain one additional command, with the syntax "#name;" where 
`name' is the name of a registered image (see `CguiLoadImage' for 
details). The meaning of this is that the 
image `name' will be drawn on top of the button instead of a text. 
If there is both a text label and an image specified, then the label 
will be drawn below the image.\par \pard \li800 \pard \li800 
The label text may also contain an underscore. This will be 
recognised as as a "newline" command and the label will be drawn 
in two partitions. The '_' will not be drawn. \par 
The text will be centred. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  CallBack: A pointer to a function written by you, which will be 
called when the user clicks the button. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  data: A pointer to any data you want, which will be passed along 
to `CallBack' (You should of course not use local variables for 
this, since they will not exist when you exit the calling function). 
\par}\pard \li400 \pard \li400 \par The default behaviour is to ignore right mouse button clicks. 
Return value: an identification key to the object. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v AddCheck}AddCheck(int x, int y, const char *label, int *sel);\par }
{\li400 This is a check box which toggles between being on and being off when the 
user clicks it. `sel' points to an integer, which is 1 for on and 0 for 
off. 
Return value: an identification key to the object. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v AddFlip}AddFlip(int x, int y, const char *label, const char *const*strs, int *sel);\par }
{\li400 This is like a check box, but displayed differently: `strs' is an array 
of two strings, the first of which will be displayed when `sel=0' and the 
second when `sel=1'. 
Return value: an identification key to the object. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v MkRadioContainer}MkRadioContainer(int x, int y, int *var, int direction);\par }
{\li400 To create a group of radio buttons, call first this function, then add 
the radio buttons using `AddRadioButton', and finally call 
`EndRadioContainer' to finish.\par 
Return value: an identification key to the container. 
Prameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  x,y: The position of the object (or you can use "direction commands"). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  var: Points to an integer describing which radio button is selected. 
The first button that you add is number 0, the second is 1, etc. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  direction: Specifies whether the sequence of buttons shall be placed 
vertically or horizontally. Use macros R_HORIZONTAL and R_VERTICAL. 
In case of R_HORIZONTAL it also recognises the optionally EQUALWIDTH. 
\par}\pard \li400 \pard \li400 \pard \li400 \par Return value: an identification key to the container. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v AddRadioButton}AddRadioButton(const char *name);\par }
{\li400 Adds a radio button to a radio button sequence. The first button added 
will get number 0, next 1 and so on. To start a radio button sequence, 
call `MkRadioContainer'.\par 
Return value: The id number of the button.\par 
Parameter: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  label: The label to be displayed  on the button, following the 
same specification as for buttons. 
\par}\pard \li400 \par Return value: an identification key to the object. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v EndRadioContainer}EndRadioContainer(void);\par }
{\li400 Terminates a sequence of radio buttons. If you don't terminate it, 
subsequent objects will go into the same container and your window will 
not look very nice. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v AddIcon}AddIcon(int id, int x, int y, const char *iconname, void (CallBack)(void*), void *data);\par }
{\li400 This function adds an icon object to the specified node. An icon object 
is a movable bitmap (i.e. the user can "drag and drop" it with right 
mouse button). The image is specified in the label text, just like with 
buttons.\par 
Currently you can only place icons on the desktop, so pass ID_DESKTOP 
for id.\par 
You can obtain the current position of the icon by calling 
`GetObjectPosition' (this can be useful e.g. if you want the program to 
arrange the icons in the same way next time you start it).\par 
Return value: The id number of the icon.\par 
Parmeters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  id: The node to put the icon into - in current version of CGUI 
this should always be ID_DESKTOP (the desktop). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  x,y: The position of the icon. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  label: The syntax and meaning of the string is the same as for 
`AddButton'. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  CallBack: A pointer to your function. It will be called when the 
user made a successful click on the icon. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  data: A pointer to any data. It will be passed to your function when 
called. 
\par}\pard \li400 \pard \li400 \pard \li400 \pard \li400 \pard \li400 \par Return value: an identification key to the object. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v GetObjectPosition}GetObjectPosition(int id, int *x, int *y, int *wx, int *wy);\par }
{\li400 Gives the current position (top left corner) of an object.\par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  id: The object asked for 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  x, y: The coordinates (relative to the container it exists in). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  wx, wy: The coordinates related to window it exists in. 
\par}\pard \li400 \pard \li400 \pard \li400 \par Return value: 1 if ok 0 if error (i.e. invalid id). 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v AddDropDown}AddDropDown(int x, int y, int width, const char *label, int *sel, const void *data, int n, void (*CallBack) (const void *data, int i, char *s));\par }
{\li400 Drop down boxes can be used for the same purpose as radio buttons, i.e. 
let the user make a selection from several alternatives. The selection 
will be reflected in the program as one of the values in the range 
[0..n-1] The DropDownBox uses another way for presentation of the 
alternatives. The DropDownBox requires less space in the dialogue window 
than the radio-buttons. On the ohter hand it is required one extra 
command to make the different alternatives visible (dropped down). 
If there are lots of alternatives or if there are lots of controls in the 
dialogue window, the DropDownBox is to prefer.\par 
To achieve the result of a selection - just examine your value pointed to 
by sel. This can typically be done when the dialogue window is closed. 
Optionally this may be done by an additional call-back function, which 
will be called after each selection made by the user. See AddHandler\par 
If the DropDownBox shall be used just to display a certain state or 
setting, rather than to provide a control to the user: use `DeActivate'\par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  x,y: The position of the object (or you can use "direction commands"). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  width: the width in pixels of the display field (the width of the 
label is not included). If width is set to 0, a width enough to 
display any of the alternatives without clipping, will be 
calculated. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  label: an optional text-label for the box 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  sel: a pointer to the variable that controls the selection (and that 
will be updated when a new selection is made by user). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  data: pointer to any of your data to create the list of text 
alternatives from 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  n: the number of alternatives 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  CallBack: a pointer to a function that you must write. This function 
will always be passed "data" as its first parameter when called. The 
second parameter will be a number in [0..n-1]. The function shall 
use the two first parameters to create a string "s", which after 
return will be the text associated with number i. 
\par}\pard \li400 \pard \li400 \pard \li400 \pard \li400 \pard \li400 \pard \li400 \pard \li400 \par Return value: an identification key to the object. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v AddSlider}AddSlider(int x, int y, int length, int *ctrl, int start, int end,\sa0  int option, int id);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 int {\xe\v AddSliderFloat}AddSliderFloat(int x, int y, int length, float *ctrl, float start, float end, int ndecimals, int option, int id);\par }
{\li400 The default direction of a slider is horizontal.\par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  x,y: The position of the object (or you can use "direction commands"). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  length: the length of the slider (this is the actual sliding length, 
the size of the entire object may be larger than this). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  ctrl: a pointer to some variable of your program which value 
controls the position of the slider handle, and that is affected by 
the user actions. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  start: the min-value of `ctrl' 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  end: the max-value of `ctrl' 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  ndecimals (for the flot version of the function): the number of 
decimals to be printed in the labels of the slider in case the 
option SL_LABEL is passed. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  option: either of: 
SL_SCALE - A scale will be drawn. The slider will use `length' and 
(end - start) to decide how to draw the scale. 
SL_LABEL - Numbers (start and end points) will label the scale of 
the slider, valid only if SL_SCALE is set. 
SL_STYLE1 - The slider will be drawn in an alternative style (diamond) 
SL_STYLE2 - The slider will be drawn in an alternative style (slide-rule) 
SL_STYLE3 - The slider direction will be vertical (the specified 
`length' will be the height rather than the width of the sliding). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  id: an optional reference to some other object, that will be 
updated during sliding. This can be used to display the exact value 
in e.g. an editbox. 
\par}\pard \li400 \pard \li400 \pard \li400 \pard \li400 \pard \li400 \pard \li400 \pard \li400 \pard \li400 \par Return value: an identification key to the object. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v AddDropDownS}AddDropDownS(int x, int y, int width, const char *label, int *sel, const char * const *strs, int n);\par }
{\li400 This is a simplified version of AddDropDown. I can be used only if your 
text-alternatives happens to be an array of pointers to strings. 
In other respects it is equivalent to AddDropDown.\par 
Return value: an identification key to the object. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v MkCanvas}MkCanvas(int x, int y, int width, int height, void (*CallBack)(BITMAP *bmp, int x, int y, void *data), void *data);\par }
{\li400 This function will create a canvas on which your function `CallBack' may 
draw whatever it want. It will be called each time the mouse generates an 
event, i.e. when the position or button state has changed. The current 
co-ordinates will be passed to the call-back together with 
the private data. If you will also examine all key-presses, you can 
install a new KeyBoard handler.\par 
Parmeters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  x,y: The position of the object (or you can use "direction commands"). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  width, height: the size of the canvas 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  CallBack: A pointer to your function. It will be called each time 
there is some change in the mouse state or position. It will also be 
called when a refresh is requested (initially by DisplayWin and any 
call to Refresh with id or with the id of any predecessors of `id'). 
`CallBack' can get the mouse-button state from the Allegro variable 
mouse_b.\par \pard \li800 \pard \li800 \pard \li800 
If `CallBack' make some drawing on bmp, these will not be visible on 
the screen until Refresh has been called. 
Parameters to `CallBack': 
\par {\li1200 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  x,y: the current position of the mouse in local co-ordinates of 
the bitmap `bmp'. When called because of initialisation the 
function will be passed -1 as value for `y'. The first call is 
guaranteed to come before any mouse event. Your function must be 
prepared to receive an initialisation call also later (CGUI may 
need to do this whenever the window or any container containing 
the canvas are re-built).\par \pard \li1200 
Subsequent calls because of a `Refresh'-call will pass -1 as 
`x'-value. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  data: the pointer data is passed 
\par}\pard \li800 \pard \li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  data: A pointer to any data. It will be passed to your acll-backi 
function when called. 
\par}\pard \li400 \par Return value: an identification key to the object. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v SetBlitLimit}SetBlitLimit(int x1, int y1, int x2, int y2);\par }
{\li400 This function may be used to reduce the area of an object that CGUI blits 
to screen. It must be called prior to the call to Refresh, and has effect 
only during that call (you must call it each time). The coordinates shall 
be related to the object and are inclusive. The function is only 
meaningful to call for canvas object blitting. 
The call to SetBlitLimit is not identical to a call to set_clip. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b extern int {\xe\v cgui_use_vsync}cgui_use_vsync;\par }
{\li400 A global variable that may be used to switch off vsync in CGUI (it is 
set to 1 by default). CGUI uses vsync when Refresh or DisplayWin is 
called directly or when these functions are indirectly called. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v AddTag}AddTag(int x, int y, const char *tag);\par }
{\li400 Tag is simple text object with the default grey background and it 
doesn't handle any events, and it is not outlined in any way.\par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  x,y: The position of the object (or you can use "direction commands"). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  tag: the text to display 
\par}\pard \li400 \pard \li400 \par Return value: an identification key to the object. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v AddEditBox}AddEditBox(int x, int y, int width, const char *label, int conversion_code, int string_buffer_size, void *data);\par }
{\li400 This function creates an edit box, which lets the user edit the text 
"data", and is formatted according to "format".\par 
Return value: id number of the edit box.\par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  x,y: The position of the object (or you can use "direction commands"). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  width: The width of the edit field of the edit box (not counting 
the label) 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  label: A text label placed to the left of the edit-field 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  conversion_code: A code specifying how the edit box shall convert data 
to text and the reverse. This can be either of: 
\par {\li1200 \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FBYTE - An unsigned integer number. Size of *data is sizeof(char). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FSHORT - A signed integer number. Size of *data is sizeof(short). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FINT - A signed integer number. Size of *data is sizeof(int). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FLONG - A signed integer number. Size of *data is sizeof(long). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FSTRING - A string. Size of the buffer pointed to by `data' is 
given by `string_buffer_size'. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FPTRSTR - A string. `data' points to a pointer pointing to 
dynamically allocated memory, or `data' points to a pointer 
that is NULL. Size of data is unlimited. The pointer pointed 
to by `data' will be update due to reallocation of the string 
memory if needed. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FPOINTS - A signed integer number eventually followed by a 
half-character. Size of *data is sizeof(int). The value pointed 
to is interpreted as its integer value divided by 2. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FBPOINTS - A signed integer number eventually followed by a 
half-character. Size of *data is sizeof(char). The value pointed 
to is interpreted as its integer value divided by 2. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FFLOAT - A floating point number. Size of *data is sizeof(float). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FHEX1 - A hexadecimal number. Size of data is sizeof(char). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FHEX2 - A hexadecimal number. Size of data is sizeof(short). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FHEX4 - A hexadecimal number. Size of data is sizeof(long). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FOCT1 - A, octal number. Size of data is sizeof(int). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FOCT2 - A, octal number. Size of data is sizeof(int). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FOCT3 - A, octal number. Size of data is sizeof(int). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FOCT4 - A, octal number. Size of data is sizeof(int). 
\par}\pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \par In addition to these codes the following can be used combined with 
these (ored together), to specify optional formatting. 
\par {\li1200 \par \par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FNAME - Is only valid when combined with FSTRING or FPTRSTR. The 
leading letter of each word will be converted to upper case if 
is not already, and the rest of the words will be converted to 
lower case, like names use to be written. The formatting is made 
instantly when the user is typing. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FBLANK0 - Shows a blank edit box if the value i 0. Only valid when 
combined with FBYTE, FSHORT, FINT, FLONG, FPOINTS or FBPOINTS. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FUNDEF - Shows a question mark if the value pointed to by `data' 
\par \pard \li1200 \pard \li1200 \pard \li1200 \par is undefined. Only valid when combined with FBYTE, FSHORT, FINT, 
FLONG, FPOINTS or FBPOINTS. The representation of an undefined 
value depends on which of the conversion codes that is used. 
\par {\li1600 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  B_UNDEF_VAL - for FBYTE 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  S_UNDEF_VAL - for FSHORT 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  I_UNDEF_VAL - for FINT 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  L_UNDEF_VAL - for FLONG 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  P_UNDEF_VAL - for FPOINTS 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  BP_UNDEF_VAL - for FBPOINTS 
\par}\pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \par The values of these macros can be found in cgui.h. Note that 
if the "undefined value" may occur as a value of your variable 
it may confuse the user if you use FUNDEF. 
\par}\pard \li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  string_buffer_size: This is only valid if `format' is FSTRING, and 
in that case it is the size of the string buffer pointed to by `data'. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  data: The data to be edited, e.g. a char* in case of FSTRING format, 
int* in case of FINT format etc. 
\par}\pard \li400 \pard \li400 \par Return value: an identification code to the object. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v AddUserDefinedWidget}AddUserDefinedWidget(int x, int y, int w, int h,  void (*Draw)(void *data, struct BITMAP *bmp, enum cgui_widget_sates state), void single_click(void *data), void *data);\par }
{\li400 Creates a user define object. By defualt it is activated with single click.\par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  x, y: The position of the object (or you can use "direction commands"). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  w, h: The width and height of the widget. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  Draw: A pointer to a function that you have written. This function will 
be called whenever CGUI decides that it is appropriate. Parameters to 
that function must be: 
\par {\li1200 \pard \li1200 \pard \li1200 \pard \li1200 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  data: This is the same 
pointer as you pass to AddUserDefinedWidget (the last parameter). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  bmp: A pointer to a bitmap of your widget. This is where you shall 
draw the appearance of your widget. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  state: Tells which mouse state your widget is in. The alternatives 
are listed below. 
\par {\li1600 \pard \li1600 \pard \li1600 \pard \li1600 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  CGUI_WIDGET_STATE_NORMAL: The normal state when there is no mouse 
interaction with your widget. This case must always be handled, this 
will occur e.g. to display your widget for the first time in your 
application. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  CGUI_WIDGET_STATE_OVER: The mouse pointer is held over your widget and the 
buttons are not pressed. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  CGUI_WIDGET_STATE_DOWN: The button is pressed when the mouse pointer is over 
your widget. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  CGUI_WIDGET_STATE_DOWN_BESIDE: The button has previously been 
correctly pressed when the mouse pointer was over your widget, and it is 
still held down but the mouse pointer is beside the widget. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  CGUI_WIDGET_STATE_GRIPPED: The button is pressed when the mouse pointer is over 
your widget and your widget has previously been assigned the grippable property 
using SetObjectGrippable. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  CGUI_WIDGET_STATE_DRAGGING_OVER: A grippable widget has previously been gripped 
and the mouse pointer is now held over your widget and the mouse button is still 
held down and your widget has previously been assigned the droppable property 
using SetObjectDroppable. 
\par}\pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  single_click: A pointer to a function that you have written. This function will be 
called by CGUI when the user clicked on your widget. Parameters to 
that function must be: 
\par {\li1600 \pard \li1600 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  data: This is the same pointer as you pass to AddUserDefinedWidget (the last parameter). 
\par}\pard \li1200 \pard \li1200 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  data: A pointer to any data of your application. 
\par}\pard \li800 \pard \li800 \par \par}\par Return value: The id number of the widget.\par 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v TabOnCR}TabOnCR(int id);\par }
{\li400 Makes the carriage returns work like tabs in an edit-box, i.e. focus 
moves to next object in the tab-chain. Useful if you have a number of 
edit-boxes in a dialogue window, and the user are supposed to enter a 
large amout of data. 
Returns 0 if it fails (i.e. id is invalid) else non-0. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v GetEditData}GetEditData(int *scan, int *ascii, int *offset);\par }
{\li400 If you adds an optional callback to an edit-box (with a call to 
AddHandler) you may be interested in the current keypress, or maybe of 
the current position in the string. Maybe you are also interested in 
changing these values. Use GetEditData and SetEditData functions for 
this.\par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  scan,ascii: the memory location pointed to by scan/ascii will be 
updated with the current key-press. NOTE! if editing is in progress 
and the user terminates the editing by some action that forces the 
editing to be terminated, the ascii value will be as for "enter", 
i.e. '\\r' but the scan value will be set to TERMINATE_EDIT 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  offset: a pointer to the position within the string. 
\par}\par}\pard \li0 \pard \li0 \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v SetEditData}SetEditData(int scan, int ascii, int offset);\par }
{\li400 If you adds an optional callback to an edit-box (with a call to 
AddHandler) you may be interested in the current keypress, or maybe of 
the current position in the string. Maybe you are also interested in 
changing these values. Use GetEditData and SetEditData functions for 
this. Note! You are only allowed to call these function from within the 
callback function. If not, the calls will be ignored.\par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  scan,ascii: the previously pressed keys will be replaced with the 
passed values, and the current position will be updated to curpos 
(before processing the keys) 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  offset: a new print position within the string. 
\par}\par}\pard \li0 \pard \li0 \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v CguiEditBoxSetSelectionMode}CguiEditBoxSetSelectionMode(int mode);\par }
{\li400 If `mode' is 1 then the current selection in edit boxes will be replaced with 
the letter corresponding to the pressed key or with the clipboard text in 
an paste operation. If `mode' is 0 the current selection will remain 
unchanged. The default is 0. The setting is global. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v AddStatusField}AddStatusField(int x, int y, int width, void (*FormatFunc)(void *data, char *string), void *data);\par }
{\li400 This function creates an object in which a single row-text may be 
displayed. The field reserved for text is of fixed width and height (the 
height is enough to display one row of text) and is outlined by a frame. 
The text will be right aligned and clipped if necessary. 
The text will be produced by the function `FormatFunc', which is a 
function that you must write. `data' is a pointer to any of your data, 
and it will be passed to `FormatFunc' whenever called. 
The difference to `AddTag' is that the status-field may change the text 
from time to time. A typical use is to display some value or text that 
will change from time to time.\par 
Save the id-number and when, for some reason data changes, just call 
Refresh(id);\par 
The status field will be put into the current node. It may be a good idea 
to create a specific container using `StartContainer' e.g. at the bottom 
of a window, for this purpose.\par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  x,y: The position of the object (or you can use "direction commands"). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  width: the width of the text-field 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  FormatFunc: a call-back function called when text is to be drawn 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  data: a pointer to some data 
\par}\pard \li400 \pard \li400 \pard \li400 \pard \li400 \par Return value: an identification key to the object. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v AddProgressBar}AddProgressBar(int x, int y, int w, int h);\par }
{\li400 Adds a progress bar. The current value can be updated by a call to 
`UpdateProgressValue'.\par 
Return value: an identification key to the object. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v UpdateProgressValue}UpdateProgressValue(int id, int percent);\par }
{\li400 Updates the value of the progress bar `id'. The bar will updated on the 
screen\par 
Returns 1 on sucess, 0 if `id' does not exist or does not refer 
to a progress object. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v AddTextBox}AddTextBox(int x, int y, const char *string, int width, int nrows, int options);\par }
{\li400 Creates a simple multi-row text-box. This can be used for various 
purposes, typically: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  To display a brief info-text in a dialogue, where you always want 
the entire text to be shown and don't want to fiddle with the 
height needed. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  To display a not too long info-text (or a text which exact length is 
not known at compile time, but known to be not to long) in a 
dialogue, where you always want the entire text to be shown and 
don't want to fiddle with the height needed. The box is able to 
adapt its size to the contained text. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  To display a text which length you know nothing about. You can then 
put a limit on the hight of the box (e.g. so that it doesn't get 
a size much larger then the screen), in which case it automatically 
gets a browsing object. 
\par}\pard \li400 \pard \li400 \pard \li400 \par The default behaviour (if `nrows' and `options' are set to 0) is to 
automatically control the line-feeds. The text will be broken into rows 
to fit the specified width. Sequences of more than one whitespace will be 
displayed as one single space. The line-feeds will be inserted at 
whitespace positions (if possible). The height of the box will be the 
height that is required to display the text. This behaviour can be 
overridden, see details below\par 
A copy of the text pointed to by `string' is used. 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  x,y: The position of the object (or you can use "direction commands"). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  string: the text to display 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  width: the text width in pixels (the frame will occupy some more 
pixels). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  nrows: If non-zero forces a browsing object to be attached to the 
text-box, and the box will be of the fixed height that is required 
to contain `nrows' number of rows using the current font. If the 
text is longer than `nrows' the browsing object will 
be active. A combination with the `TB_PREFORMAT' option usually 
makes it more useful. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  options: Just pass 0 if you need none of them, or: 
\par {\li1200 \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  TB_FRAMERAISE will outline the text with a raised frame. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  TB_FRAMESINK will outline the text with a sunked frame. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  TB_PREFORMAT will handle each whitespace character 
individually. Line-feed characters will force newlines 
whenever they occure. Multiple spaces in sequence will be 
drawn as they are defined in the font in use. The default tab 
width is 8. If you want some other setting, just att that number 
to the option flags. Lines that are too long to fit into the 
current width of the text-box, will be truncated. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  TB_LINEFEED_ If you don't use the option `TB_PREFORMAT', i.e. 
let the box do automatic line feeds to fit the text into the 
specified width, you may still want to force new lines. You can 
do that useing this option. Use the character '_' (underscore) 
to indicate where to force line fieeds. (The '_' conforms to the 
`mktext' utility, see the tools directory of CGUI). If you need 
to draw an '_' just use two in sequence so to insert multiple 
linefeeds in sequence, you have to put a space between 
the underscores, like  "_ _". This option can not be combined 
with `TB_PREFORMAT'. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  TB_FIXFONT will use CGUI's built-in fix-font. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  TB_WHITE will set the text background to white instead of the 
default grey. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  TB_TEXTFILE The `string' parameter will be used as the name 
of a file. That file will be loaded and the contents of it will 
be displayed. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  TB_FOCUS_END This has only meaning if the textbox has fixed 
height (i.e. nerows is non-zero), and the effect will be that the 
last line of text to disply will be shown (if more than one 
page to view than the top part will be scrolled out). If you 
change the content of the box it will be browsed to the end again. 
\par}\pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \par \par}\par Use `UpdateTextBoxText' if you need to change the displayed text.\par 
Return value: an identification key to the object. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v TextboxHighlighting}TextboxHighlighting(int id, int bgcolor, int textcolor, int row_index);\par }
{\li400 Makes a certain row in a textbox highlighted. This row does not follow the 
text if scrolled. It is a fixed row w.r.t. the textbox widget.\par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  id: An id to a textbox. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  bgcolor: The background to be used to highlight a row. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  textcolor: if this is not -1 the text on the highlighted row will be 
drawn with it. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  row_index: The index to the row that will stay highlighted. 
\par}\par}\pard \li0 \pard \li0 \pard \li0 \pard \li0 \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b const char *{\xe\v TextboxGetHighlightedText}TextboxGetHighlightedText(int id);\par }
{\li400 Returns a pointer to a string with the text of the row that is highlighted. 
The memory of string belongs to the textbox.\par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  id: An id to a textbox. 
\par}\par}\pard \li0 \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v TextboxScrollDownOneLine}TextboxScrollDownOneLine(int id);\par }
{\li400 Scrolls the text down one line. This will have no effect if the textbox has no 
scrollbar.\par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  id: An id to a textbox. 
\par}\par}\pard \li0 \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v UpdateTextBoxText}UpdateTextBoxText(int id, const char *string);\par }
{\li400 Changes the current text of the textbox `id' to the string pointed to 
by `string'. A copy of the text is made. 
Returns 1 on sucess, 0 if `id' is not valid or does not refer 
to a text object. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v HookSpinButtons}HookSpinButtons(int id, int *var, int delta1, int delta2, int minv, int maxv);\par }
{\li400 Creates a pair of spin-buttons. These let the user change the value of 
the integer variable pointed to by `var'. The value will be increased 
by a mouse-press on the up-arrow, and decreased by a press on the down- 
arrow.\par 
Return value is the id of the conainer that will be created for the 
spin-buttons.\par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  id: The spin-buttons will be put immediately to the right of the 
object refered to by `id'. After a user click and during a "scroll" 
the object `id' will be refreshed in order to maintain a correct 
displayed value. Typically `id' may refer to an edit-box, but in 
some cases a status-field will be better (rarely a drop-down would 
be prefered). There are no restrictions on the type of object of 
`id'. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  var: A pointer to the variable which value will be uppdated by 
the spin-buttons. The memory must of course be allocated while 
processing. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  delta1: the steps of increment/decrement at low value of `var' 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  delta2: the steps of increment/decrement at high value of `var', use 
same value as for delta1 if you want it to be constant for the 
entire interval. If delta1 and delta2 differs the currently used 
delta will change linear over the value-interval. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  minv: the lower limit of the value of the variabel pointed to by 
`var' 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  maxv: the upper limit of the value of the variabel pointed to by 
`var' 
\par}\pard \li400 \pard \li400 \pard \li400 \pard \li400 \pard \li400 \pard \li400 \par Return value: an identification key to the object. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v Refresh}Refresh(int id);\par }
{\li400 Redraws a specific win-object. If the object contains (recursively) other 
object these will also be refreshed. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v Activate}Activate(int id);\par }
{\li400 This function activates an inactive object. An object must be active to 
take notice about events like mouse-clicks and hot-keys. Some object 
types reflects their `active state' by the colour of its text label.\par 
To make a change visible it is necessary to call Refresh(id);\par 
The default state of an object after its creation is active. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v DeActivate}DeActivate(int id);\par }
{\li400 The function makes an object inactive, i.e. the object will not take 
notice about events like mouse-clicks and hot-keys. Some object 
types reflects their `active state' by the colour of its text label. 
To make a change visible it is necessary to call Refresh(id);\par 
An inactive object may be re-activated by a call to the function 
`Activate'. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v SetObjectGrippable}SetObjectGrippable(int id, void *(*Grip)(void *src, int id, int reason), int flags, int buttons, void *data);\par }
{\li400 Set the specified object as grip-able, which means that the user may grip 
the object by use of mouse-button (with the intention to later on drop it 
somewhere else).\par 
NOTE! An object can't be both "slidable" and "grippable". 
\par {\i This means that objects that by default has the slidable propery 
set, will loose that when beeing set to "grippable". For the moment this 
will probably only affect edit-boxes, which may loose the ability to get 
text marked by use of the mouse if they are set "grippable" with use of 
left mouse button (i.e. mouse down and moving will be interpreted as a 
drag-drop in stead of as marking text in that case, since there are 
obviously no way to ditinguish between the two operations).\par}
You must be aware that the drag-drop mechanism can be used very 
dynamically, and carefully handle your pointers. Several disjunct or 
overlapping drag-drop channels may be used in parallel (use the flags to 
distinguish the data objects dropped). The hot-key handler is in work 
during the drag-drop operation, so the user can e.g. close 
the window from where the object was gripped, implying that the object 
returned by grip must not rely on its window being open.\par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  id: The id-key of the object to be grippable 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  Grip: A pointer to a function that you have written. It will 
be called by CGUI three or maybe four times for 
each drag-and-drop action. 
Below are listed the predifined values of the reason-parameter to 
the "Grip", "Drop" and "Slide" call-back functions. 
\par {\s1 \f1\fs18 \pard \li800 \pard \li800 
\par     DD_OVER_GRIP
\par     DD_GRIPPED
\par     DD_UNGRIPPED
\par     DD_SUCCESS
\par    \par}\pard \li800 \par {\li1200 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  First call to Grip: the reason parameter will be DD_OVER_GRIP 
and src will be the src-pointer. If, for some reason, the object 
don't want to be gripped then just let Grip return NULL. To 
accept being gripped just return any non-zero-pointer. Typically 
(but not necessarily) this will be the input parameter 
`src' to Grip. 
NOTE! The returned address is the one that will be passed to Grip 
as src-parameter in subsequent calls to Grip, and in all calls to 
any Drop-function. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  Second call to Grip: reason will be DD_GRIPPED, and src will be 
the address returned by Grip in the first call. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  Third call to Grip: reason will be DD_UNGRIPPED, and src will be 
the address returned by Grip in the first call. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  4:th call to Grip: reason will be DD_SUCCESS, and src will be the 
address returned by Grip in the first call. If not successfully 
dropped, there will be only three calls. 
\par \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \par The calls to the Grip-functions gives your program the 
opportunity to take special actions when the object is gripped 
and dropped. This includes things like highlighting the gripped 
object, changing the cursor and so on. By examining the reason 
parameter in the later call-backs you will, if the drag-drop is 
intended to represent a move rather than copy, be able to know 
if the object is to be deleted or not. 
\par}\pard \li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  flags: Establishes the drag-drop connections. A drag-drop connection 
means that a grip-able object (specified by a call to 
SetObjectGrippable) may be dropped on a drop-able object (specified 
by a call to SetObjectDroppable). A drag-drop connection exists if 
AND-ing of the flags of a grip-able object with the flags of a 
drop-able object results in non-zero. An object may be drop-able on 
itself. To avoid conflicts between different 
drag-drops, use the function `RegisterDragFlag'. \par \pard \li800 
Note! The highest bit is in use by CGUI's file-browser and the 
next highest by icons. You must not use these bits for your 
drag-and drops while these CGUI-objects are available for 
the user. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  buttons: The grippable property can not co-exist with the slidable 
property. I.e. assigning both Grip and Slide to the same mouse 
button is impossible, but both click and double-click can co-exist 
with grip on the same mouse button. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  data: a pointer to any data object. This pointer will be 
passed as `src'-parameter to Grip in the first call (see above). 
\par}\par}\pard \li0 \pard \li0 \par \par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v SetObjectDroppable}SetObjectDroppable(int id, int (*Drop)(void *dest, int id, void *src, int reason, int flags), int flags, void *data);\par }
{\li400 Set the specified object as drop-able by installing the call-back 
function `Drop'. "Drop-able" means that the user may drop an object 
(previously gripped by use of the mouse) on it.\par 
`Drop' will always be called by CGUI at least 3 times for each 
drag-and-drop action that is completed by the user. The parameter reason 
in the call-back informs which type of call that is concerned. The 
`Drop'-function will only be invoked if the following conditions are 
fulfilled: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  The destination is active (this is the default state which may be 
changed by Activate/DeActivate). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  The destination has at least one drop-flag that matches the source 
(i.e. AND-ing them results in non-zero). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  Some gripped object is either: 
\par {\li1200 \pard \li1200 \pard \li1200 \pard \li1200 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  over the destination or 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  is not over the destination now, but was previously 
\par}\pard \li800 \pard \li800 \pard \li800 \par \par}\par The interpretation of the reason parameter at call-back: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  DD_OVER_DROP tells that some object has been gripped, and is being 
dragged over `dest' object and that the flags of the source and 
the destination object is matching 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  DD_END_OVER_DROP tells that there is no longer an object over 
\par \pard \li800 \pard \li800 \par The DD_OVER_DROP and DD_END_OVER_DROP calls may of course be 
repeated any number of times depending on the actions by the user. 
If one object has received DD_OVER_DROP and the cursor moves 
directly to another object, the DD_END_OVER_DROP will come to the 
first one before DD_OVER_DROP comes to the new one. 
NB! A pair of DD_OVER_DROP and DROP_OVER_END doesn't indicate a 
successful drop. These calls are only intended to give your 
call-back function the opportunity to e.g. highlight the 
destination object to indicate for the user that it is drop-able. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  DD_SUCCESS tells that the source object has been dropped on the 
destination object. This call will be issued after the 
DD_SUCCESS-call to the Grip-function of the gripped object. 
\par}\pard \li400 \par Parameters to `SetObjectDroppable': 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  id: the id-key of the object concerned 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  Drop: a call-back function written by you. 
Parameters of the call-back function "Drop": 
\par {\li1200 \pard \li1200 \pard \li1200 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  dest: the address of the actual object (the parameter object in 
the call to SetObjectDroppable is transparently transmitted) 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  id: the id of the drop-object 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  src: the address of the actual source object that is gripped (the 
parameter object in the call to SetObjectGrippable is 
transparently transmitted). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  reason:any of the DD_* flags listed above 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  flags: resulting value of the flags of the gripped object and the 
object dropped on. If no special Drop-handling is required, Drop 
may be set to NULL. 
\par}\pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  flags: function of flags see SetObjectGrippable. The drop-flags will 
be stored separately from the grip-flags, they don't need to be the 
same for a certain object. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  data: Any data transparently passed to Drop in all calls. 
\par}\par}\pard \li0 \pard \li0 \par \par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v SetObjectSlidable}SetObjectSlidable(int id, int (*Slider)(int x, int y, void *data, int id, int reason), int buttons, void *data);\par }
{\li400 This function is used by CGUI internally and is exported just for 
completeness, for the moment I can't see any use for it in an application 
program.\par 
NOTE! An object can't be both "slidable" and "grippable".\par 
`SetObjectSlidable' set the specified object as slidable, which means 
that the user may grip the "hot" area of the object by use of 
mouse-button (with the intention to slide the hot area (or maybe a part 
of it like a handle) to another part of the object, within the visible 
area).\par 
Parameters to SetObjectSlidable: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  id: the id-key of the object concerned 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  Slider: a call-back-function defined in your program that will be 
called by CGUI, first when gripped, then for each movement. 
Parameters to `Slider': 
\par {\li1200 \pard \li1200 \pard \li1200 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  x,y: the current coordinates (within object) 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  data: a pointer to some data 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  id: the id of the object 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  reason: the reason why Slider was called, this may be either of: 
\par {\li1600 \pard \li1600 \pard \li1600 \pard \li1600 \pard \li1600 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  SL_OVER mouse cursor is over 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  SL_OVER_END mouse cursor is not over but was previously 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  SL_STARTED dragging did just start (mouse button is now down) 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  SL_PROGRESS dragging is in progress 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  SL_STOPPED mouse button released 
\par}\pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \par \par}\pard \li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  buttons: The mouse buttons for which "sliding" shall be allowed. The 
slide event-type can not co-exist with the "grip" event-type. 
If you e.g. assign "slide" to the left button it will be impossible 
to grip the object with the left button, but click and double-click 
will be OK. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  data: pointer to the data that later on (when the events occurs) 
will be passed to "Slider" 
\par}\par}\pard \li0 \pard \li0 \par \par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v SetObjectDouble}SetObjectDouble(int id, void (*DoubleCall)(void *), void *data, int button);\par }
{\li400 Makes an object being double-clickable. "DoubleCall" will be called after 
a successful double-click. 
Assigning double-click e.g. to the left button allows the left button 
to be used for single clicks to on the same object (the single click is 
not issued until the "doubleclick" delay has expired). In addition the 
same object may be either possible to slide or to grip with the same 
button (the click and double-click events will not be launched until 
"slidedelay" or "gripdelay" respectively time has expired)\par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  id: the id-key of the object concerned 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  DoubleCall: The call-back function. It will be passed the "data" 
pointer. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  data: the data to be passed to "DoubleCall" 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  buttons: The double-click event can co-exist with all other event 
types 
\par}\par}\pard \li0 \pard \li0 \pard \li0 \pard \li0 \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v ToolTipText}ToolTipText(int id, const char *text);\par }
{\li400 Applies the text `text' to the object `id' to be used as a tool-tip text. 
If `text' contains `_' characters these will be interpreted as new lines.\par 
About tool tips: These are messages popping up to the user when moving 
the cursor over an object. This can be needed for 2 purposes 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  The object has only an icon, and maybe the user don't understand 
what command it represents. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  The object has a text label, with or without an icon, but there are 
needed some more information that will not fit into a label. 
\par}\pard \li400 \pard \li400 \par Return value: 1 on sucess else 0 (i.e. `id' is not valid). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v SetView}SetView(int id, int flags);\par }
{\li400 Specifies how the object `id' will be viewed. If you switch any of the 
two first flags you need to call `DisplayWin' ance again if that has 
already been done. 
Also the tool tip viewing can be controlled by 'SetView'. 
\par Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  id: The id-key of the object concerned. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  flags: Any of the following option may be used in any combination: 
\par {\li1200 \pard \li1200 \pard \li1200 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  SV_HIDE_LABEL: If `id' has both an icon and a label then only the 
icon will be shown. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  SV_HIDE_ICON: If `id' has both an icon and a label then only the 
label will be shown. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  SV_NO_TOOLTIP: Deactivates the drawing of tool tips. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  SV_PREFERE_BRIEF: Ignored if `SV_NO_TOOLTIP' is set. If the 
object has both a tool tip text and a label text then the label 
text will be viewed as tool tip. Viewing tool tips will 
be skipped either if none of texts are present or if there is 
only a label text and it is already visible as label.\par \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 
I.e. briefly: "show tool tips when possible without repeating 
info, prefere brief info if there is a choice". 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  SV_PREFERE_LONG: Ignored if `SV_NO_TOOLTIP' is set. If the 
object has both a tool tip text and a label text then the tool 
tip text will be viewed as tool tip. \par \pard \li1200 
I.e. briefly: "show tool tips when possible without repeating 
info, prefere long info if there is a choice". 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  SV_ONLY_BRIEF: Ignored if `SV_NO_TOOLTIP' is set. If the 
object has a label text then the label text will be viewed as 
tool tip if it is not already used as label. \par \pard \li1200 
I.e. briefly: "show tool tips when possible without repeating 
info and there exists a brief text". 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  SV_ONLY_LONG: Ignored if `SV_NO_TOOLTIP' is set. Only if the 
object has a tool tip text there pop up a tool tip. 
\par}\pard \li800 \pard \li800 \par \par}\par If an object has both a label and an icon and none of the flags 
SV_HIDE_LABEL and SV_HIDE_ICON are specified (the default case) then 
both of them will be drawn as a part of the object.\par 
Only one of the flags  SV_PREFERE_BRIEF, SV_PREFERE_LONG, SV_ONLY_BRIEF 
and SV_ONLY_LONG can be specified. The default setting is SV_PREFERE_LONG.\par 
If `id' is some container rather than a simple object this command will 
affect also all the descendants of `id'.\par 
Return value: 1 on sucess else 0 (i.e. `id' is not valid). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v CguiSetToolTipDelay}CguiSetToolTipDelay(int delay);\par }
{\li400 This function sets a start delay that cgui will wait until a tooltip is 
displayed. The setting is global. The default value is 0. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v CguiSetToolTipAnimation}CguiSetToolTipAnimation(int step, int delay);\par }
{\li400 This function sets tool tip animation. The tool tip will slide in from 
left moving `step' pixels with `delay' milliseconds between each move. 
A step of 0 disables the animation of tooltips. The setting is global. 
The default value is 0 for both step and delay. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v Remove}Remove(int id);\par }
{\li400 This function will call `Destroy' but it will also clean up the screen 
from the object(s), i.e. the background of the containing node will be 
drawn on the area of the former object. The containing node will however 
not be rebuild, i.e. all the remaining objects will keep their 
positions.\par 
You don't need to call `Destroy' when you want to close a window, 
`CloseWin' will take care of all objects in it.\par 
In general the userinterface will be better if you avoid to remove 
single objects. If your program goes into a state such that some 
object(s) will be redundat or constitue illegal selecteion(s), then it 
is better to deactivate them. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v Destroy}Destroy(int id);\par }
{\li400 This function frees all memory associated with the specified object `id'. 
If the object contains other objects, like e.g. containers and 
tab-windows do, all the sub-objects will be removed too (recursively). 
The screen will remain unchanged. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v GetPressedButton}GetPressedButton(int id);\par }
{\li400 Returns the mouse button (left or right) that was latest pressed on the 
specified win-object. 
Return value: 1 on sucess else 0 (i.e. `id' is not valid). 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v PointerOn}PointerOn(int id);\par }
{\li400 Places the mouse pointer above the object. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v ModifyHeader}ModifyHeader(int id, char *newlabel);\par }
{\li400 Modifies the window-header text with the text of "newlabel". An 
additional call to refresh is necessary to make the changes visible. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v AddHandler}AddHandler(int id, void (*Handler)(void *data), void *data);\par }
{\li400 Installs the application call-back function "Handler" and "data" into a 
window object.\par 
Objects like check-boxes, radio-buttons etc. normally doesn't need any 
call-back, so when creating these you don't need to specify any call-back 
function. In some cases it may however be convenient to get a call-back 
for user events to these object types. E.g. if your program needs to 
activate/deactivate other objects directly when the state of an check-box 
is changed. In these case "AddHandler" may be used for installing such an 
optional handler.\par 
Not all type of objects support this facility. Return value 0 tells that 
the installation failed. Currently the following object types supports 
the optional Callback to be installed: edit-boxes, radio-buttons, 
check-boxes, drop-down boxes, sliders and flip-objects.\par 
In case of an edit-box, you are probably interested in getting some 
information about the editing that is in progress (maybe you want to 
distinguish between a letter-key-press and a carriage-return key-press). 
Call for GetEditData to get available info. For edit-boxes your call-back 
will be invoked before handling the event (the pressed key), in case of 
other object types the event will be processed first.\par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  id: the id-key of the object concerned 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  Handler: a pointer to a function written by you. It will be called 
in case of user event, and the pointer data will be transparently 
passed 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  data: a pointer to any of your data 
\par}\pard \li400 \pard \li400 \pard \li400 \par Return value: 1 on sucess else 0 (i.e. `id' is not valid). 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v SetMouseButtons}SetMouseButtons(int id, int buttons);\par }
{\li400 Mouse button alternatives: LEFT_MOUSE, RIGHT_MOUSE\par 
Thid function changes the specified objects sensibility for clicks to 
the specified mouse button(s). (default is the left mouse button)\par 
Return value: 1 on sucess else 0 (i.e. `id' is not valid). 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v RegisterDragFlag}RegisterDragFlag(int flag);\par }
{\li400 This is for the "drag-and-drop" facility. Some part of your application 
may use some flag(s) for some object(s). If there is a risk that the same 
flags may used for different purposes (e.g. the printer-monitoring 
function uses bit 31), you should register the flags before using them.\par 
Return value: 0 if none of the bits was already registered, else the 
occupied bits.\par 
Use the return value to determine if it is safe to activate the 
drag-and-drop.\par 
NOTE! Dropping of unexpected objects will _in best case!!_ crash your 
program!\par 
Parameter: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  flag: The integer containing the bit(s) (not the bit-number). The 
bit(s) will be registered unconditionally. 
\par}\par}\pard \li0 \par \par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v UnRegisterDragFlag}UnRegisterDragFlag(int flag);\par }
{\li400 This function unregister the flag(s). 
Return value: 0 if none of the bits was already registered, else the 
occupied bits.\par 
Parameter: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  flag: The integer containing the bit(s) (not the bit-number). The 
bit(s) will be unregistered unconditionally. 
\par}\par}\pard \li0 \par \par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v RegisterRefresh}RegisterRefresh(int id, void (*AppUpd)(int id, void *regdata, void *calldata, int reason), void *regdata);\par }
{\li400 Will register a callback-function for the widget `id'. This function 
will be called, whenever your program calls `ConditionalRefresh' 
\par \par \par Since the registration is associated with a widget it there will be 
an automatic unregistration when that widget is removed. 
\par \par \par The name indicates that the purpose of the call-back is to make some kind 
of screen update, which was also the original purpose. However, the 
functionality may be used for arbitrary purposes. 
\par \par \par If you register several "refreshers" and not all of them needs to be 
involved each time, you can let the function calling `ConditionalRefresh' 
make a directed "message" by passing different `reason' parameters and 
let the AppUpd functions examine it when called.\par 
If several AppUpd functions will call `Refresh' for different or maybe 
even the same object, that would have lead to a sequence of blits to 
screen. However during the `ConditionalRefresh' call the blitting is 
temporary tyrned off, and a final blit is issued at end of the call (a 
minimal area will then be blitted)\par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  id: The id to the widget to register this call-back function for. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  AppUpd: A pointer to a callback function written by you. 
\par \pard \li800 \pard \li800 \par \par Parameters to AppUpd: 
\par {\li1200 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  id: The id of object registered for. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  regdata: The registered data. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  calldata: A pointer to the data specific for the call, passed by 
you when calling `ConditionalRefresh. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  reason: Some value. Passed via `ConditionalRefresh' 
\par}\pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  regdata: A pointer to some data that will be passed to `AppUpd' when 
called. This will be registered together with `AppUpd' in the widget. 
\par}\par}\pard \li0 \par \par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v ConditionalRefresh}ConditionalRefresh(void *calldata, int reason);\par }
{\li400 Will call all `AppUpd' functions registered by `RegisterRefresh'. The calls 
will be performed in a top-down manner over the widget tree, starting at 
the root window. If an `AppUpd' function removes the widget that it is 
registered for, the refresh will stop. 
\par \par \par Even if several of the called `AppUpd' calls `Refresh' for one or several 
widgets, there will be a single screen update at the end. 
\par \par \par Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  calldata: A pointer to some data that will be passed to all `AppUpd' 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  reason: Any value. This will be passed to all `AppUpd', and can be 
used by these functions to filter out the desired calls. 
\par}\par}\pard \li0 \pard \li0 \par \par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v Click}Click(int id);\par }
{\li400 This function simulates a single mouse click (left) on the object `id' 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v MakeStretchable}MakeStretchable(int id, void (*Notify)(void*), void *data, int options);\par }
{\li400 This function creates a "handle" on the right and bottom edges of the 
object, and a "handle" at the right bottom corner of it. 
This makes it possible for the user to adjust the width and height of the 
object. The handle in the corner makes it possible to stretch both width 
and height at the same time. 
The "handles" are invisible, but the mouse cursor will change its shape 
when moving it over them.\par 
All objects are allowed to be stretchable, but not all will notify the 
stretching, e.g. a container that have an ADAPTIVE size, will after the 
re-sizing operation immediately return to its previous size calculated as 
the minimum to show all its contents (i.e. ADAPTIVE overrides 
stretching).\par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  listid: the id of the list to be stretchable 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  Notify: an optional call-back function that will be notified when 
the the size of the object has been changed. The new size 
(difference from the size initially calculated by CGUI) may be 
achieved by a call to GetSizeOffset, and may later be stored by 
your program to make it possible to start the program next time 
with the size of the object that the user likes. Pass NULL if you 
don't need the call-back. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  data: a pointer to some data that will be passed to `Notify' when 
called by the object. Pass NULL if not used. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  options: may be used to inhibit bottom or right side handle (and 
only want it to be stretchable in one direction). Macros: 
NO_HORIZONTAL and NO_VERTICAL 
\par}\pard \li400 \pard \li400 \pard \li400 \pard \li400 \par Return value: 1 on sucess else 0. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v GetSizeOffset}GetSizeOffset(int id, int *x, int *y);\par }
{\li400 This function may be used to get the changes in size of an object. A 
change of the size may only occur  if it is stretchable (or if the size 
has been adjusted with SetSizeOffset). 
Return value: 1 on sucess else 0 (i.e. `id' is not valid). 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v SetSizeOffset}SetSizeOffset(int id, int x, int y);\par }
{\li400 This function may be used to adjust the size of an object. A default size 
of an object is always calculated at creation time (normally this is the 
size enough to carry its label or icon). This size may be changed by this 
function. Typically it is used in conjunction with GetSizeOffset to 
restore the size of objects modified by user after a window has been 
closed and re-opened.\par 
Note: If justification commands like FILLSPACE are used in conjunction 
with the relative positioning of an object (like DOWNLEFT etc) this may 
override the offset setting. 
The function must be called before the call to 'DisplayWin' to have 
effect.\par 
Return value: 1 on sucess else 0 (i.e. `id' is not valid). 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v InsertPoint}InsertPoint(int id);\par }
{\li400 Moves the "logical insertion point" where new objects will be added 
to after the `id' object. Any new objects that you add after calling 
this function will be positioned as if they were added right after 
`id' was added.\par 
This can sometimes be meaningful when you make changes in a container 
that already has object positioned with "direction commands".\par 
The new "logical insertion point" is local to the container where `id' 
lives.\par 
Changes that are made in a window after it has been made visible (by 
a call to  `DisplayWin') will not be visible until `Refresh' is called 
for appropriate part of the window. If "direction commands" are used, 
the appropriate parts, which is normallay the entire window, of the 
window also needs to be re-built (by a call to `ReBuildContainer') before 
the refresh. Both will be done for the entire window if you call 
`DisplyWin' again.\par 
Returns 1 if id referes to an existing object, otherwise 0. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v MkVerticalBrowser}MkVerticalBrowser(int x, int y, void (*CallBack) (void *data), void *data, int *viewpos);\par }
{\li400 Creates a vertical "browsing object" consisting of one bar with a slider 
handle for browsing and scrolling, and two scroll buttons.\par 
The usage is quite staight forward, and the easiest way to unserstand is 
to look into the browse example in the `examples' directory of CGUI.\par 
For a detailed description the following {\b naming\par}\par  convention is 
introduced: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  "browsing object" - this object (the user can use it to browse and 
scroll in another object, the "browsed object"). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  "browsed object" - this can be any other object which displays 
something that possibly is to large to be shown all at once. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  "view port" - is the area on the screen where the user can see 
(possibly a part of) the "scrolled area". The "view port" may be 
the same as the area of the "scrolled object", but also less (if 
the "scrolled object" e.g. has some kind of frame). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  "scolled area" - the area to show in the "view port" 
(if longer than the "view port" the user will be able to scroll or 
browse it to be able to see other parts of it). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  "scrolling resolution" - for certain useges is quite enough for the 
user if the "scrolling area" jumps ahead more than one pixel at a 
time. A lower resolution (more pixels of jump) will speed up the 
scrolling. The least scrolling resolution is 1. 
\par}\pard \li400 \pard \li400 \pard \li400 \pard \li400 \pard \li400 \par The "browsing object" performs all calculations needed and call a 
function of yours (see below) when the user interacts with the "browsing 
object". 
At some point your program may want "scrolled area" to move within 
the "view port". It can then inform the "browsing object" about the new 
state, see `NotifyBrowser'.\par 
The size of the "scrolled area" may for some reason change during the 
program execution. This will be the case e.g. if the thing to display is 
an image and you provide the user with a tool to zoom the image or to 
change to some (different sized) image. Also in such cases you need to use 
`NotifyBrowser' to tell the "browsing object" about the new size.\par 
During program execution the size of the "view port" may change (as 
well as the prefered size of the "browsing object") in which case you 
can use `SetBrowserSize' to inform the "browsing object" about it. (A 
change of the "view port" size typically can occure if the "browsed 
object" is possible to re-size by the user.\par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  x,y: The position of the "browsing object" (you can use "direction 
commands" as well as numeric coordinates).  Probably you want this 
to be to the RIGHT of the "browsed object". 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  CallBack: A function written by you. It will be called any time when 
the user has used any of the scroll buttons or the slider handle. 
The main purpose of this function is to update the area within 
"view port". 
Parameters: 
\par {\li1200 \pard \li1200 \pard \li1200 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  data: The data pointer you passed to `MkBrowser'. 
\par}\pard \li800 \pard \li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  data: A pointer to any data that you want to be passed to `CallBack'. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  viewpos: A pointer to a variable of yours that specifies the start 
position of the "scrolled area" in the "view port" (number of 
pixels). The browser will both read and update the value of that 
variable.\par \pard \li800 \pard \li800 
\par}\par If the current "scrolled area" is smaller than the size of 
the "view port" (set by `SetBrowserSize') then the "browsing object" will 
deactivate itself.\par 
The sliding handle will change its length as expected if the the 
"scrolled area", "view port" or "browsing object" changes its size.\par 
Return value: 1 on sucess else 0. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v MkHorizontalBrowser}MkHorizontalBrowser(int x, int y, void (*CallBack) (void *data), void *data, int *viewpos);\par }
{\li400 Creates a horizontal "browsing object". See `MkVerticalBrowser' for 
details. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v NotifyBrowser}NotifyBrowser(int id, int step, int scrolled_area_length);\par }
{\li400 Forces the "browsing object" `id' to update its status according to the 
parameters. NOTE! You also need to call `NotifyBrowser' if you change the 
value of the variable pointed to by `viewpos' (see `MkVerticalBrowser') 
so the "browsing object" can make necessary re-calculations according to 
the new position.\par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  id: The id of the "browsing object". 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  step: The "scrolling resolution" in pixels. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  scrolled_area_length: The length of the "scrolled area" in pixels. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  viewpos: The start position of the "scrolled area" that currently 
is to be viewed in the "view port" (in pixels). 
\par}\pard \li400 \pard \li400 \pard \li400 \pard \li400 \par Return value: 1 on sucess else 0.\par 
This function makes no update of the screen. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v SetBrowserSize}SetBrowserSize(int id, int view_port_length, int browsing_length);\par }
{\li400 Specifies the dimensions for a browsing object.\par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  id: The id of the "browsing object". 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  view_port_length: The length of the "view port" ("length" means 
either width or height depending on if it is a horisontal or 
vertical browser). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  browsing_length: The desired length of the "browsing object" itself. 
("length" means either width or height depending on if it is a 
horisontal or vertical browser). 
\par}\pard \li400 \pard \li400 \pard \li400 \par Returns 1 if sucess else 0. \par 
This function makes no update of the screen. It can be useful if the 
browsed object is re-sized (see `MakeStretchable'). 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b extern int {\xe\v continous_update_resize}continous_update_resize;\par }
{\li400 This is a global variable that controls the updating behaviour of an 
object when stretched by the user.\par 
If continous_update_resize is set to 0 (default), then the object that is 
stretched by the user will not show its new size until the user releases 
the mouse button that gripped the stretch-handle.\par 
If continous_update_resize is set to 1, then the object that is 
stretched by the user will continously show the current size. 
\par}\par \par \par \brdrb\brdrs\brdrw15\brsp20 \par \pard \par \par {\xe\v Direction commands for object positioning}
In CGUI you can specify the position of object using co-ordinates 
explicitly, like 
\par {\s1 \f1\fs18 
\par    AddButton(13, 132, "Cancel", my_func, my_dataptr);
\par    \par}However, you will probably re-design your window a number of times during 
development, and each time you will probably need to re-calculate the 
position of the "Cancel".\par 
In order to make the development process more convenient for you, CGUI 
provides the {\b "Direction command"\par}\par  facility. This means that you 
just need to tell the direction of the object related to the recent ones. 
The call will instead look like e.g.: 
\par {\s1 \f1\fs18 
\par    AddButton(DOWNLEFT, "Cancel", my_func, my_dataptr);
\par    \par}The position fo the "Cancel" button will be calculated in run-time and it 
will adapt to the contents above as well as the run-time calculated size 
of other objects. It's highly recommended that you use the "direction 
commands" instead of explicit co-ordinates. It's also highly recommended 
that you combine this with the 'ADAPTIVE' feature of windows and 
containers to make your life easier.\par 
The following 3 "direction commands" are the most "easy to use" ones, 
when using them think of adding object like when typing text (from left 
to right, from top to bottom): 
\par {\li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  TOPLEFT will put the object in the top left corner of the container 
(or window). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  RIGHT will put the object on the right side of the previously 
created object, and the top edges of the two will be aligned. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  DOWNLEFT will put the object at the beginning of a "new row", i.e. 
at the left edge of the container (or window) and below the bottom 
edge of the prevous "object row". 
\par}\pard \li0 \pard \li0 \pard \li0 \par The below ones are used by CGUI itself, and may occasionally be useful 
for other purposes. 
\par {\li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  DOWN puts the object below the previous one (aligned left edges). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  LEFT will put the object on the left side of the previous object, 
withe aligned top edges. (i.e. it is meaningful to issue a 'LEFT' 
object only after a RIGHT|ALIGNRIGHT or DOWN) 
\par}\pard \li0 \pard \li0 \par The following additional fill flags may be combined with a direction 
command. The main point is create rows or columns with nice looking 
object groups. Normally you should set the same flag to all objects in 
such an "object row" or "object column". 
\par {\li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  FILLSPACE: The objects in the "object row" or "object column" will 
fill all available space in the container (or window), or to be more 
precise:\par \pard \li400 
All space found between a "sequence of n objects", before the 
left one and after the right one will first be summed. The space 
needed for the current distance will be subtracted from that. 
The rest will be divided into n equal sized pieces. Each object will 
the get its auto calculated size extended with that amount of pixels. 
The "sequence of objects" is defined as some consecutive objects 
with identical "additional commands" and the  same top co-ordinates. 
By default the space-filling will be horizontally. If you want 
vertical filling the add the VERTICAL flag.\par 
Optionally you may also specify both VERTICAL and HORIZINTAL to make 
it fill up in both directions. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  EQUALHEIGHT: All objects in an "object row" will get the same 
height as the one that requries the biggest height. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  EQUALWIDTH: All objects in an "object column" will get the same 
width as the one that reqiures the biggest width. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  VERTICAL: This will only be notified as an specification to 
FILLSPACE. 
\par}\pard \li0 \pard \li0 \pard \li0 \par You are allowed to use the flags above to fill the space around any 
sequence of objects, including other sub containers. However the result 
will not always be as expected if their sizes are 'ADAPTIVE' since the 
size of such containers are calculated after the positions of the entire 
object tree has been calculated.\par 
The "align"-flags will align the object to an edge of the container (or 
window). \par 
Both flags may be applied to the same object.\par 
If you use ALIGNRIGHT for more than one object on the same "object row", 
these will overlap (there is an analogous problem with 
ALIGNBOTTOM). 
\par {\li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  ALIGNRIGHT This flag will align the object to the right of a 
container (or window). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  ALIGNBOTTOM This flag will align the object to the bottom of a 
container (or window). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  ALIGNCENTRE This flag will centre in x-direction. Other object on the 
same y-level will make objects messed up. May be combined with 
ALIGNBOTTOM. 
\par}\pard \li0 \pard \li0 \pard \li0 \par The "insertion point" of a new object will normally be after the 
previously added one in the same container. You can modify the insertion 
point using the function  `InsertPoint'. 
\par \par \par \par \brdrb\brdrs\brdrw15\brsp20 \par \pard \par \par {\xe\v Id-numbers of objects}
Functions that creates visible objects returns an id-number. This number 
is unique.\par 
For simple usage of the GUI you don't need this id. For advanced usage 
there may sometimes be necessary to later on (when the window creation 
has already been finished by a DisplayWin-call) refer to an object. In 
these cases you have to save the id-number returned by the 
object-creating function, and make use of it when you are about to call 
the CGUI-function that reqiures the id-number.\par 
Typical CGUI-functions that needs the id-number are Activate, DeActivate, 
Refresh, Remove, Destroy.\par 
Since the id-number is unique for the entire application you can as well 
access objects in an "old" window (not the top one). Specially the 
`Refresh' may be useful in this case. \par 
Some of the CGUI-functions will apply to an entire group of objects if 
you refer to a node object like a container, a list, a window etc.\par 
If the specified id-number is not found the operation is ignored.\par 
Note! Removing a single object will not give you any problem (i.e. CGUI 
will not give you any), but it is not intuitive for the user - 
deactivation is better than removing. Adding objects to an already 
existing ADAPTIVE window may raise the problem for your program to 
determine where it may be free space in the window to avoid overlapping 
(remember that the direction command will refer to the "previous object" 
object). \par 
Some objects are of "container type". That is an object that contains 
other objects. Examples of containers: 
\par {\li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  Container 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  Tab-window 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  List-box 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  Radio-group 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  The menu-bar 
\par}\pard \li0 \pard \li0 \pard \li0 \pard \li0 \pard \li0 \par The functions that create containers will also return an id-number. 
\par {\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Menus}Menus\par }
A menu bar has to be "opened" first. The menu bar serves as a container 
for the different menus. It is required one call for each menu. Each of 
them will establish a call-back function. It is necessary to terminate 
the sequence of created menus by "closing" the container. 
\par \par Each menu is connected to a call-back function which is a part of the 
application. This call-back function will be activated when the user 
wants to drop down the menu. The only thing it shall do is to create the 
items in the dropped down menu. Each of these are in the same manner 
connected to a call-back function, which may either drop yet another 
(sub-)menu or perform a direct action. 
\par \par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v MakeMenuBar}MakeMenuBar(void);\par }
{\li400 Creates a container specially designed for entering menus-items in a 
window. The point is to issue subsequent calls to MkMenuBarItem. 
NB! The sequence of calls to MkMenuBarItem must be terminated by a call 
to EndMenuBar. If you forget this other objects will be placed together with 
the menu-items, and it will all look junky. \par 
MakeMenuBar returns an id-number. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v EndMenuBar}EndMenuBar(void);\par }
{\li400 Closes a container opened by MakeMenuBar. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v MkMenuBarItem}MkMenuBarItem(const char *text, void (*CallBack) (void *), void *data);\par }
{\li400 Creates one menu-item within an opened menu bar (opened by MakeMenuBar). 
\par \par \par Return value: the id of the menu item (non-zero) 
\par \par Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  text: the menu text to display 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  CallBack: a pointer to a function written by you. This function will 
be called by CGUI when the user wants the menu to be dropped down. 
Prior to the call, CGUI has prepared for receiving calls from 
your `CallBack' in order to create menu-items (i.e. calls to 
MkMenu*). There is no restriction on the object types that may be 
created by `CallBack', but the menu may appear crazy if you put 
other than the special menu-item-objects there (the menu and the 
menu items co-operate in the event processing to make mouse events 
and key-presses to work as expected). `CallBack' is supposed to NOT 
open or close any window, since a window build is in progress when 
it is called. The parameter passed to CallBack is the "data"-pointer 
that you pass as last argument. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  data: a pointer to any data that you want your call-back function to 
receive. 
\par}\par}\pard \li0 \pard \li0 \pard \li0 \par \par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v MkScratchMenu}MkScratchMenu(int id, void (*CallBack)(void*), void *data);\par }
{\li400 \par \par `MkScratchMenu' will immediately drop down a menu and invoke `CallBack'. 
The position of the menu will be at the mouse cursor position. 
Return value: the id of the drop-menu (non-zero) 
\par \par Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  id: typically you want a scratch-menu dropped down if the user 
clicked on a certian object. If you prefere that the menu shall be 
placed at the edge of this object rather than above it, then pass 
the is of that object. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  CallBack: a pointer to a function written by you. This function will 
be called by CGUI when the user wants the menu to be dropped down. 
Prior to the call, CGUI has prepared for receiving calls from 
your `CallBack' in order to create menu-items (i.e. calls to 
MkMenu*). There is no restriction on the object types that may be 
created by `CallBack', but the menu may appear crazy if you put 
other than the special menu-item-objects there (the menu and the 
menu items co-operate in the event processing to make mouse events 
and key-presses to work as expected). `CallBack' is supposed to NOT 
open or close any window, since a window build is in progress when 
it is called. The parameter passed to CallBack is the "data"-pointer 
that you pass as last argument. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  data: a pointer to any data that you want your call-back function to 
receive. 
\par}\par}\pard \li0 \pard \li0 \pard \li0 \par \par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v MkSingleMenu}MkSingleMenu(int x, int y, char *label, void (*CallBack) (void *), void *data);\par }
{\li400 \par \par `MkSingleMenu' does the same work as `MakeMenuBar' + `MkMenuBarItem' + 
`EndMenuBar' with one call to `MkMenuBarItem'. I.e. it creates amenu-bar containing 
one menu-item. It looks slightly different (it is indicated that it is a 
menu by a "down-arrow".\par 
Return value: the id of the menu (non-zero) 
\par \par Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  x,y: The position of the object (or you can use "direction commands"). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  label: the label text that will be displayed on the menu 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  CallBack: a pointer to a function written by you. This function will 
be called by CGUI when the user wants the menu to be dropped down. 
Prior to the call, CGUI has prepared for receiving calls from 
your `CallBack' in order to create menu-items (i.e. calls to 
MkMenu*). There is no restriction on the object types that may be 
created by `CallBack', but the menu may appear crazy if you put 
other than the special menu-item-objects there (the menu and the 
menu items co-operate in the event processing to make mouse events 
and key-presses to work as expected). `CallBack' is supposed to NOT 
open or close any window, since a window build is in progress when 
it is called. The parameter passed to CallBack is the "data"-pointer 
that you pass as last argument. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  data: a pointer to any data that you want your call-back function to 
receive. 
\par}\par}\pard \li0 \pard \li0 \pard \li0 \pard \li0 \par \par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v MkMenuItem}MkMenuItem(int sub, const char *text, const char *shortcut, void (*CallBack) (void *), void *data);\par }
{\li400 Creates one menu-item within a dropped down menu. There is actually 
two different types that can be created by this function: (1) A menu-item 
that is the selection point for a sub-menu, and (2)a menu-item that is 
just a simple selection (that closes all menus).\par 
Return value: the id of the menu item (non-zero) 
\par \par Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  sub: A flag indicating if this menu-item will open another sub-menu 
or if it is just a direct selection. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  label: The text to label the menu-item. See section `Labels' for 
details about commands embedded in the label-string. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  shortcut: another (optional) text. This text is right-aligned. It is 
intended to be used to inform about a shortcut. Just pass the empty 
string ,"", if you have no need for it. (There is no check for this 
short-cut, it's up to you to tell the truth to the user). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  CallBack: A pointer to a function written by you. 
Case (1), `sub' was non-zero: This function will 
be called by CGUI when the user wants the menu to be dropped down. 
Prior to the call, CGUI has prepared for receiving calls from 
your `CallBack' in order to create menu-items (i.e. calls to 
MkMenu*). There is no restriction on the object types that may be 
created by `CallBack', but the menu may appear crazy if you put 
other than the special menu-item-objects there (the menu and the 
menu items co-operate in the event processing to make mouse events 
and key-presses to work as expected). `CallBack' is supposed to NOT 
open or close any window, since a window build is in progress when 
it is called. 
Case (2), `sub' was zero : This function will be called when the user 
selects this item. The menu(s) will be closed before the call. There 
is no restriction on what the CallBack can do (actually a typical 
task is probably to open or close some window). 
The parameter passed to CallBack is the "data"-pointer that you pass 
as last argument. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  data: A pointer passed to "CallBack". 
\par}\par}\pard \li0 \pard \li0 \pard \li0 \pard \li0 \pard \li0 \par \par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v MkMenuRadio}MkMenuRadio(int *selvar, int n, ...);\par }
{\li400 Works similar to AddRadioButton, but is intended only for menus. 
\par \par Return value: the id of the menu item (non-zero) 
\par \par Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  selvar: the variable which value is controlled by the radio-buttons 
(and which value contols the initial display of them). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  n: the number of radio-buttons connected to "selvar". The first one 
representing value 0, next value 1 etc. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  ...: This must be (NOTE IMPORTANT!)exactly n text-strings, each 
one telling the text label to put on the corresponding radio-button 
selector 
\par}\par}\pard \li0 \pard \li0 \pard \li0 \par \par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v MkMenuCheck}MkMenuCheck(int *checkvar, const char *text);\par }
{\li400 Works similar to AddCheck-button, but is intended only for menus. 
Return value: the id of the menu item (non-zero) 
\par \par Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  checkvar: the variable which value is controlled by the check-button 
(and which value cont  rols the initial display of it). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  text: the label of the selection 
\par}\par}\pard \li0 \pard \li0 \par \par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v HookMenuClose}HookMenuClose(void (*CloseHook)(void*), void *data);\par }
{\li400 This function installs CloseHook. This is a pointer to a function written 
by you. It will be called when the menu is closed. 
HookMenuClose will do nothing if it is not called from a "menu drop-down" 
-function like the call-back passed to `MkMenuItem'. Actually it will do 
the same thing as `HookExit', with the difference that you don't need 
to now the id-number (which you normally don't know). 
\par \par The benefit of installing the CloseHook may be e.g. to get the chance  to 
free memory allocated by the drop-down function. If the menu is closed 
because the user made a selection of an item (or some item in a sub-menu) 
the call-back of that item will be called prior to CloseHook. 
\par \par Returns non-zero on sucess. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v MkGroove}MkGroove(void);\par }
{\li400 A horizontal groove will be put into any node as a delimiter. The purpose 
is to visually group objects into logical groups. This may be specially 
useful in menus.\par 
Return value: the id of the groove 
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Containers}Containers\par }
About Container objects: 
"Container" is a recursive (or "nested") construct. This means that a 
container may contain an arbitrary number of objects that themselves 
may be containers or "simple" objects like push-buttons etc.\par 
The nesting may be done in arbitrary number of levels.\par 
A container is just a rectangular fraction of its parent window (or 
container), normally used to group together some objects to make 
the window more attractive for the user.\par 
Sometimes you may want it simply for grouping objects without seeing the 
container itself. Another time it may be used to make a more distinct 
group of objects with a frame and a label informing user about its 
content. Yet another time it may be used just to force a sequence of 
objects to be of the same size. 
\par \par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v StartContainer}StartContainer(int x, int y, int width, int height, char *label, int options);\par }
{\li400 The objects in a window may be grouped into containers. Objects created 
between StartContainer and EndContainer will refer to the co-ordinates 
of the container. This also applies to direction commands (like TOPLEFT, 
DOWNLEFT, RIGHT..) as well as explicit x,y-co-ordinates. The objects will 
"belong" to the container. This means that if the container later on is 
deleted (by a call to `Destroy') all the objects in the container will 
also be destroyed. After `EndContainer' has been 
called, all subsequently added objects will be put into the same window 
or sub-window as where the container is (it works like "closing" the 
container for input).\par 
Return value is the id of the container.\par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  x,y: The position of the object (or you can use "direction commands"). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  width,heght: size of the container. If width,heght is replaced by 
the ADAPTIVE command the container will be large enough to show all 
its content. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  label: an optional text to be displayed as a label of the container. 
If omitted (i.e. empty string), then no space is reserved for it in 
on the screen. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  options: CT_BORDER and/or CT_OBJECT_TABLE 
\par {\li1200 \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CT_BORDER outlines the container with a border line. If a label 
is passed the line will be broken to make place for the label. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CT_OBJECT_TABLE which simply joins the container to the 
"tab-chain" as a node. To work correctly it requires that you 
put the objects in a tabular form. It is only possible to make 
a CT_OBJECT_TABLE in one level of nesting. 
\par}\par}\pard \li400 \pard \li400 \pard \li400 \par}\par \par \par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v EndContainer}EndContainer(void);\par }
{\li400 Closes a contaioner created by `StartContainer'. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v SelectContainer}SelectContainer(int id);\par }
{\li400 This function will select the container (node) `id' as input for 
subsequently created objects. If the node `id' is not in the currently 
operating window, the window of `id' will be set to operating. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v SetDistance}SetDistance(int hdist, int vdist);\par }
{\li400 This function sets the space used by CGUI when deciding positions for 
objects that has been added with the "direction commands" like `RIGHT', 
`DOWN' etc. and when deciding the size of a container or window that is 
created with the `ADAPTIVE' size.\par 
You can do the same, but specify measurments more detailed, by using 
`SetSpacing'. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v SetSpacing}SetSpacing(int id, int left, int h, int right, int top, int v, int bottom);\par }
{\li400 This function sets the space used by CGUI when deciding positions for 
objects that has been added with the "direction commands" like `RIGHT', 
`DOWN' etc. and when deciding the size of a container or window that is 
created with the `ADAPTIVE' size.\par 
The settings will affect the container or window specified by `id'. The 
changes will be visible the next time you call `DisplayWin' or 
`ReBuildContainer'.\par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 left: Space between the left edge of a container (or a window client 
area) and the leftmost object. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 h: Space between any two objects related with the `RIGHT' or `LEFT' 
direction commands. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 rightx: Space between the right edge of a container (or a window client 
area) and the rightmost object. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 top: Space between the top edge of a container (or a window client 
area) and the upper object. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 v: Space between any two objects related with the `DOWN' or `DOWNLEFT' 
direction commands. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 bottom: Space between the bottom of a container (or a window client 
area) and the lowest object. 
\par}\pard \li400 \pard \li400 \pard \li400 \pard \li400 \pard \li400 \pard \li400 \par The return value is 1 if `id' is a valid id of a container, else 0. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v ReBuildContainer}ReBuildContainer(int id);\par }
{\li400 This function will re-build a container. If you add objects into a container 
when the window has already been displayed (with a call to DisplayWin) you 
can use this function make up the container only. Calling DisplayWin once 
again will also work fine, but will update the entire window. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v EmptyContainer}EmptyContainer(int id);\par }
{\li400 This function will destroy all objects within the specified container. 
The image of the objects will not be removed (the pixels will remain 
unchanged in the bitmap of the node). To remove their appearance from 
the window you must also re-build the node, e.g. by a call to 
DisplayWin();. This is preferably done after inserting new objects into 
the node (the need to insert new objects is probably the reason why 
'EmptyContainer' was called). 
\par \par May be useful if minor changes needs to be made to a window (typically 
extending or shrinking the window). 
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Listboxes}Listboxes\par }
A list-box is a node that contains a number of row-objects. If necessary 
there will be a "browse-handle" and two scroll-buttons beside the listbox 
(they will appear when the list contains more objects than there are 
rows). 
\par \par You must write at least 2 functions (normally 3). You must make 2 
function calls (e.g. `AddList' and `SetIndexedList'). 
\par \par The functions you have to write is: 
\par {\li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  A function that receives a pointer to the entire list-data, and 
returns a pointer to a specific object within the list. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  A function that generates the text to be drawn on one row. This 
string is made up from the object returned from the above function. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  Normally you want your program to be notified if the user clicks on 
a row. You must write a function that is called in such cases. 
\par}\pard \li0 \pard \li0 \pard \li0 \par This maybe sounds more tricky than it really is, here is an example: 
\par {\s1 \f1\fs18 
\par    int row_text(void *rowdata, char *s)
\par    \{
\par       int *row=rowdata;
\par       sprintf(s, "Data is %d", *row);
\par       return 0;
\par    \}
\par 
\par    void *index_creater(void *listdata, int i)
\par    \{
\par         int *arr=listdata;
\par         return &arr[i];
\par    \}
\par 
\par    void foo(int id, void *rowdata)
\par    \{
\par       /* Do something */
\par    \}
\par 
\par    void make_dialog_with_list(void)
\par    \{
\par         /*array and n must be static or dynamic memory, not normal local
\par         variables!*/
\par         static int array[100]=\{1,2,3,4,5\}, n=5, id;
\par         MkDialogue(ADAPTIVE, "Test-window", 0);
\par          /* add more objects here ... */
\par         AddList(TOPLEFT, array, &n, 60, LEFT_MOUSE, row_text, foo, 10);
\par         SetIndexedList(id, index_creater);
\par          /* ...or here if you need */
\par         DisplayWin();
\par    \}
\par    \par}The list properties in CGUI is controlled by the following global 
variables: 
\par {\li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  FONT *CGUI_list_font; 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  int CGUI_list_vspace; 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  FONT *CGUI_list_row_font; 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  int CGUI_list_row_f_color; 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  int CGUI_list_row_b_color; 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  int CGUI_list_fixfont; 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  int cgui_list_fix_digits; 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  int cgui_list_no_multiple_row_selection; 
\par}\pard \li0 \pard \li0 \pard \li0 \pard \li0 \pard \li0 \pard \li0 \pard \li0 \pard \li0 \par It works like this: Each time a list-box is created, CGUI will use the 
values of these variables. If you use several list-boxes in your 
application and for instance want one of these to use a fix font you 
have to set CGUI_list_font to the fix font you have loaded, and then 
restore the origin font after the list was created.\par 
The meaning of the variables: 
\par {\li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  CGUI_list_font - The font used for the lists. The default 
value is CGUI's default font. Lists that are already existing will 
not be affected by changes of CGUI_list_font. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  CGUI_list_row_font - The font used for the rows in the list. Changes 
will only be notified if set by the list-row drawing function that 
you have written. If that function does not assign the 
CGUI_list_row_font the default font for the list will be used 
instead (i.e. CGUI_list_font). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  CGUI_list_row_f_color - The default text colour of list rows 
is black. If you want to change the foreground colour of individual 
row you have can do that by assigning a different color to the global 
variable CGUI_list_row_f_color. You need to do that in your list-row 
drawing function. The setting will be reset by the list-box when the 
next row is drawn, so you have to set this for precisely the rows that 
you want to have a different color. For a general change of the 
background of list boxes rows please see CguiSetColor. 
\par \pard \li400 \pard \li400 \pard \li400 \par \par Rows with highlighted background (by default they are blue) because 
the user have selected them will not recognise any changes of colour. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  CGUI_list_row_b_color - The default background colour of list rows 
is white. If you want to change the background colour of individual 
row you have can do that by assigning a different color to the global 
variable CGUI_list_row_b_color. You need to do that in your list-row 
drawing function. The setting will be reset by the list-box when the 
next row is drawn, so you have to set this for precisely the rows that 
you want to have a different color. Rows with highlighted 
background (by default they are blue) because the user have selected 
them will get a color which is a merge between your setting and the 
highlight color. There is a heuristic to find a text color that makes 
the text easy to read. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  There is a horizontal line delimiting rows in list boxes. This line 
has the same color as the list box background by default, making it 
invisible. To make the row delimiters visible you have to change 
that color before you create the listbox. See CguiSetColor for details. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  CGUI_list_vspace - Determines the height of the total height of the 
list rows. The height of a row is the height of the font used + 1 
(for the delimiter line) + CGUI_list_vspace. To make a list more 
compact you may set a negative value (which may lead to some 
characters overlapping). The default value is 0. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  CGUI_list_fixfont - if 0, which is the default value, the text of 
the rows in listboxes will be drawn directly by Allegro. If 
non-zero, the value is used as the with of each character in the 
used font. This may be set individually for each column/row. 
This is a workaround to make it possible to draw fix fonts like 
'Courier' as fix fonts. The only way to import fonts, as far 
as I know, is the ttf2pcx tools program, and it seems to destroy the 
fix-width properties of fix-fonts. In some applications fix-fonts 
are very necessary. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  cgui_list_fix_digits - This is an alternative to CGUI_list_fixfont. 
If non-0 all digits of the string will be drawn with the witdth of 
the widest digit within the font and all other characters will be 
drawn with their own width. This is useful if you know in advance 
that the texts of all rows will contain only digits or digits with 
predifined delimiters at certain positions. 
This may be set individually for each column/row. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  cgui_list_no_multiple_row_selection - by default the "multiple 
rows" property is enabled. If this flag is set this will be disabled 
for all lists subsequently created. 
\par}\pard \li0 \pard \li0 \pard \li0 \pard \li0 \pard \li0 \pard \li0 \par CGUI_list_font, CGUI_list_column_delimiter_color and 
CGUI_list_rowdelimitercolor will be reset next time calling InitCgui. 
\par \par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v AddList}AddList(int x, int y, void *listdata, int *n, int width, int mousebt, int (*RowTextCreater)(void *rowdata, char *s), void (*Action)(int id, void *rowdata), int norows);\par }
{\li400 Creates a list box. NOTE! The list-box is not finished until you have 
also called either `SetLinkedList' or `SetIndexedList' (which both 
requires a pointer to a function that you have written). To make a 
list box work you will need to write a least one more small function 
(yet more may be needed, depending on how you configure the list). 
This second "small function" is one that calculates which string that 
shall be drawn provided some data element. \par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  x,y: The position of the object (or you can use "direction commands"). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  listdata: may be a pointer to any application data, transparently 
passed to the xxCreater-function specified by SetLinkedList or 
SetIndexedList. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  n: is a pointer to an integer specifying the number of elements that 
currently is in the `listdata' (i.e. the number of elements in your 
array). This parameter is ignored if you will put the list box into 
tree mode. The same applies also if your data to display is in a 
linked list, or to be more precise: if you will call `SetIndexedList'. 
In such cases you can just pass NULL. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  width: specifies the width in pixels of the list box rows (the frame 
and the browsebar will be added to this) 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  mousebt: specifies the mousebuttons to be handled when the user 
clicks on a row. 
\par {\li1200 \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200 LEFT_MOUSE - Your function `Action' will be called when a row in the list 
is clicked by the left mouse button. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200 RIGHT_MOUSE - Your function `Action' will be called when a row in the list 
is clicked by the right mouse button. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200 LEFT_MOUSE+RIGHT_MOUSE - Your function `Action' will be called both when 
a row in the list is clicked by the left and the right mouse button. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200 0 - `Action' will never be called. 
\par}\pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  RowTextCreater: A call-back function written by you. This will be 
called each time a list row has to be drawn. RowTextCreater will be 
called with the actual object-pointer `data' (previously created by 
the `index' or `next' function) for that row. Its purpose is to 
create a the text to be displayed on the row. 
Optionally it may also return any of the below attributes (they may 
be ored) or return zero if none of them is wanted: 
\par {\li1200 \pard \li1200 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  ROW_STRIKE will generate a line striking trough the text 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  ROW_UNDERLINE underlines that row 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  ROW_COLUMN_UNDERLINE underlines a particular column of the current 
row (only valid in case list box columns are used). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  ROW_CHECK puts a check-mark at the beginning of the row 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  ROW_UNCHECK will reserve space at the beginning of the row 
Useful to keep a stight column in a list with checked rows 
(use ROW_UNCHECK for the unchecked rows). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  COL_RIGHT_ALIGN will align the text to the right edge of the current 
column (this attribute is only available in case you have set 
columns in the list box). 
\par}\pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \par \par \par \par Parameters to RowTextCreater: 
\par {\li1200 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  rowdata: the data created by your `ApplicationDataAtIndex' 
or `IterateLinkedListOfApplication' function. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  s: Pointer to an array where `RowTextCreater' is supposed to put 
a string to be displayed for the `rowdata'. The string may start 
with an image name in which case the image will be diplayed to 
the left fo the text. The form of an image name is the same as 
for other objects, i.e. #imagename; where `imagename' is the 
name of an registered image. See CguiLoadImage for details. There 
may be spaces between the '#' and the imagename. To display a 
leading '#' on a row you need to put '##' in the string. 
\par}\pard \li800 \pard \li800 \pard \li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  Action: A call-back function that will be called when a row in the 
list-box was clicked by the user. If you don't want any action 
performed if the user clickes on a row (i.e. if you specifies 0 
for the mousebt parameter) then you can pass NULL for Action.\par \pard \li800 
Parameters to Action: 
\par {\li1200 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  id: the id of the row-object and may e.g. be used as reference 
to obtain information about which of the mouse buttons that 
was pressed (in case both are allowed). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  rowdata: the data created by your function `ApplicationDataAtIndex' 
or `IterateLinkedListOfApplication' function. 
\par}\pard \li800 \pard \li800 \pard \li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  norows: The number of rows to display at one time (i.e. the height 
of the list expressed in rows instead of pixels). 
\par}\pard \li400 \par There are lots of options to configure a list box to fit your taste, here 
are some global variables that affect the apperance of lists. 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  FONT *CGUI_list_font; 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  FONT *CGUI_list_row_font; 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  int CGUI_list_row_f_color; 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  int CGUI_list_row_b_color; 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  int CGUI_list_rowdelimitercolor; 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  int CGUI_list_vspace; 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  int CGUI_list_column_delimiter_color; 
\par}\pard \li400 \pard \li400 \pard \li400 \pard \li400 \pard \li400 \pard \li400 \pard \li400 \par Their usage are as follows: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  CGUI_list_font - will be snapped as the default font by the listbox 
when it is created. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  CGUI_list_row_font - may be used to change the font for an 
individual row. Only `RowTextCreater' can set this, and it will 
only be used on that row. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  CGUI_list_row_f_color - may be used to make the text of a single row 
to be drawn in a certain colour (default is black) 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  CGUI_list_row_b_color - may be used to make the background of a 
single row to be drawn in a certain colour (default is white) 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  CGUI_list_rowdelimitercolor the color of a pixel line that delimits 
the rows in the listbox (default is white) 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  CGUI_list_vspace - signed integer specifying a number of extra 
vertical pixels int the row height (default value is 0). The base height 
of the rows are always the height of the list's default font. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  CGUI_list_column_delimiter_color - this will be the colour of the 
column delimiter (only used if SetListColumns has been called, and 
the proper flag was passed). 
\par}\pard \li400 \pard \li400 \pard \li400 \pard \li400 \pard \li400 \pard \li400 \pard \li400 \par See also the links for functions to configure list boxes. 
\par \par \par The return value is the id of the list box. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 int {\xe\v SetIndexedList}SetIndexedList(int listid, void *(*CreateRowData)(void *listdata, int i));\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 int {\xe\v SetLinkedList}SetLinkedList(int listid, void *(*CreateRowData)(void *listdata, void *prev));\par }
{\li400 You have to use one (and only one) of these functions to tell the list box 
which function to call when a data item for a row is needed. (this will 
happen e.g. when drawing a row or when the user clicks or drags a list 
row or some other event that the list box is responsible for). 
If the data that you want to display in the list box is organized as a linked 
list, then the function `SetLinkedList' is to prefer. If your list-data is an 
array then the function `SetIndexedList' might be more convenient for you.\par 
Parameters to these functions: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  listid - the id of a list box (i.e. the value returned from `AddList'). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  CreateRowData - This should be a pointer to a function that you have 
written (an "iterator function"). The work that needs to be done for this 
function is to create a pointer to some row data that is understood by 
your functions `RowTextCreater', `Action' etc.\par \pard \li800 \pard \li800 
Parameters to these functions: 
\par {\li1200 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  The input `listdata' will be the pointer that you passed to 
`AddList' as the `listdata' parameter. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  prev/i - In case your data is an array (i.e. function 
SetIndexedList was used) then the `i' tells from which index in the 
array the datapointer should be returned. In case your data is a 
linked list (i.e. function SetLinkedList was called) then 'prev' tells 
which is your previous element, and your function `CreateRowData' 
should return a pointer to the next element (or null if there are no 
more elements). If there is no previous element (i.e. the first 
element is wanted) then `prev' will be NULL. 
\par}\pard \li800 \pard \li800 \pard \li800 \par \par}\par A typical function for array data may look something like: 
\par {\s1 \f1\fs18 
\par    void *my_index_creater(void *listdata, int i)
\par    \{
\par       struct MYDATA *d=listdata;
\par       return &amp d[i];
\par    \}
\par    \par}A typical function for linked lists may look something like below. 
Note that if prev is set to NULL then the function is supposed 
to extract a pointer to the first element using the listdata pointer. 
\par {\s1 \f1\fs18 
\par    void *my_next_creater(void *listdata, void *prev)
\par    \{
\par      /* Here we assume that a pointer to the list head was passed to AddList */
\par      struct MYDATA **m=listdata;
\par      struct MYDATA *p=prev;
\par      if (p==NULL)
\par        return *m;
\par      else
\par        return p->next;
\par    \}
\par    \par}Both functions may of course use whatever methods to calculate the data 
to return (e.g. the "data" pointer may be a pointer to any structure 
which contains a pointer to the head/array, the array may be an array of 
pointers etc.). Just another example for linked lists:\par 
\par {\s1 \f1\fs18 
\par    void *my_next_creater(void *listdata, void *prev)
\par    \{
\par      /* Here we assume that a pointer to the an empty head record was passed to AddList */
\par      struct MYDATA *m=listdata;
\par      struct MYDATA *p=prev;
\par      if (p==NULL)
\par        return m->next;
\par      else
\par        return p->next;
\par    \}
\par    \par}And yet a (maybe more practical) example: 
\par {\s1 \f1\fs18 
\par    void *my_next_creater(void *listdata, void *prev)
\par    \{
\par      /* Here we assume that a pointer to some other struct was passed to AddList */
\par      struct MYDATA_MAIN *m=listdata;
\par      struct MYLINK *p=prev;
\par      if (p==NULL)
\par        return m->list_head;
\par      else
\par        return p->next;
\par    \}
\par    \par}The return value from SetIndexedList is 1 if a listid is a valid id of a 
list, else 0. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v ListTreeView}ListTreeView(int listid, int level_width, int (*IsLeaf)(void *rowobject), int options);\par }
{\li400 This function will turn a normal list box into a tree viewer. In most 
respects it is just an ordinary list, however special list facilites like 
list columns and "hooked lists" are not supposed to work.\par 
Your tree implementation may be whatever you like, you can use either an 
iterator function for arrays (using `SetIndexedList' to install it) or for 
linked lists (using `SetLinkedList' to install it). The return value (if not 
NULL) will always turn up later as the first parameter of your iterator 
function as the root data of that level in the tree.\par 
Note however, if you use the array style iterator, then it should be 
prepared to be called with any size of the 'index' parameter and return 
NULL in case the index is too big (the list box will use that to draw some 
conclusions about the number of nodes at that level).\par 
Notable is also that the 4:th parameter, 'n', passed to `AddList' (i.e. the 
"number of list items") has no meaning for a tree viewer, so it will be fine 
if you just pass NULL to AddList.\par 
The tree view section of the list box is a part of the rows in the list 
so if you want to let the user expand and collaps nodes in the tree 
you need to at least pass LEFT_MOUSE for the 'mousebuttons' parameter 
to AddList.\par 
The list box itself will manage the expanding and collapsing of tree nodes. 
Your call-back function handling row click will only be called when the row 
is clicked, not when the node is expanded or collapsed.\par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  listid: the id returned from `AddList'. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  level_width: the width each tree level will occupy on the screen. 
Suitable value is 10 pixels or above (you should consider the 
the width of your icons when choosing a value) 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  IsLeaf: a pointer to a callback function that must return non-zero if 
'rowobject' is a leaf and 0 if 'rowobject' is an internal node that 
shall be possible to expand and collapse. \par \pard \li800 \pard \li800 \pard \li800 
'rowobject' is the data returned by your 'ApplicationDataAtIndex' or 
'IterateLinkedListOfApplication' (installed by SetIndexedList or 
SetLinkedList). \par 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  options: at present there is only one option: 
\par {\li1200 \pard \li1200 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  TR_HIDE_ROOT: This flag will cause the outermost tree root not to 
be displayed (i.e. the leftmost view is a list of sons of the 
tree root). 
\par}\pard \li800 \pard \li800 \par \par}\par The return value is 1 if a listid is a valid id of a list, else 0. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v ListTreeSetNodesExpandedState}ListTreeSetNodesExpandedState(int listid, int (*IsExpanded)(void *data));\par }
{\li400 This function will set the expanded or collapsed state of all nodes 
that are not leafs in the tree. To see the change you need to also call 
`Refresh'. Normally the expanded/collapsed state is changed by the user. 
This function can however be useful in case you want to pre-set some 
initial state of the nodes.\par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  listid: the id returned from `AddList'. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  IsExpanded: a function written by you. This function will be called 
by `ListTreeSetNodesExpandedState' once for each node in the tree. 
Parameters to IsExpanded: 
\par {\li1200 \pard \li1200 \pard \li1200 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  data: a pointer to the data object of the node (i.e. the same as 
passed to IsLeaf) 
\par}\pard \li800 \pard \li800 \par If `IsExpanded' returns non-zero the node will be set to expanded 
else collapsed. 
\par}\par The return value is 1 if `listid' is valid id of a list, else 0. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v ListTreeSetNodeExpandedState}ListTreeSetNodeExpandedState(int listid, int new_expanded_state, void *data);\par }
{\li400 This function will set the expanded or collapsed state of the specific node 
that holds the application data `data'. Normally the expanded/collapsed 
state is changed by the user. This function will however override the users 
choice.\par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  listid: the id returned from `AddList'. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  new_expanded_state: the expanded state (0=collapsed, 1=expanded) 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  data: a pointer to the data object of the node. 
\par}\pard \li400 \pard \li400 \pard \li400 \par The return value is 1 if `listid' is valid id of a list and a node pointing to `data' was found, else 0. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v InstallBelowListEndCallBack}InstallBelowListEndCallBack(int listid, void (*CallBack)(int id, void *data), void *data);\par }
{\li400 This function will install the call-back `CallBack' that will be called with 
`data' whenever the user clicks below the last current list item (i.e. on an 
empty row).\par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  listid: the id returned from `AddList'. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  CallBack: a pointer to a callback function that will handle the event 
of a click on an "empty row".\par \pard \li800 \pard \li800 
Parameters to CallBack: 
\par {\li1200 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  id: the id of the window object representing the empty row that the 
user clicked on. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  data: a pointer the data that you passed to `InstallBelowListEndCallBack'. 
\par}\pard \li800 \pard \li800 \pard \li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  data: a pointer to some data of yours that will be passed to `CallBack' when called. 
\par}\pard \li400 \par The return value is 1 if a listid is a valid id of a list, else 0. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v CguiListBoxSetToolTip}CguiListBoxSetToolTip(int listid, int mode, int options);\par }
{\li400 This function alters the tool tips viewing mode of a list box. 
\par \par \par Tool tips for the list box rows can be useful in listboxes with possibly 
long text or if there are several resizeable columns so the text on rows 
may be hidden. The text of the tool tips will be the text of all columns 
concatenated with double spaces between the columns or just the single text 
of the row if there are no columns. 
\par \par \par Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  listid: the id returned from `AddList'. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  mode: If `mode' is 1 this function will configure the listbox `listid' 
so that there will be tooltips showed whenever the mouse is over a row. 
\par \pard \li800 \pard \li800 \par \par If `mode' is 0 the above behavior will be turned off. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  options: Pass 0, there is currently no option. 
\par}\pard \li400 \par The return value is 1 if a listid is a valid id of a list, else 0. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v CguiListBoxRowSetBar}CguiListBoxRowSetBar(int color, double percentage);\par }
{\li400 This function may be useful in case you want to use a list-box to show the 
rows like in a bar diagram. 
\par \par \par Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  color: The color of the bar (the first part of the row's background). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  percentage: The lenght of the bar as a fraction of a full rows width 
(where 1.0 is a full row). 
\par}\pard \li400 \pard \li400 \par This function has only affect when called from a list-box row drawing 
function, and it will only affect the currently drawn row. If the list-box 
uses columns, the function only have effect when the call-back is called 
for the first column. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v CguiListBoxRowGetClickedColumn}CguiListBoxRowGetClickedColumn(int rowid);\par }
{\li400 Returns the column that a certain listbox column was clicked on last time, 
or -1 in case the information can not be obtained. 
\par \par \par Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  rowid: The id key of the row to get the information about. You get the 
id as a parameter to the "row select call-back" function ("Action" 
parameter to AddList). Note that this call-back function may also be 
called because of the users key-presses, not only because of mouse 
clicks. In such cases the column is not well defined. 
\par}\par}\pard \li0 \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v CguiListBoxSetColumnSelection}CguiListBoxSetColumnSelection(int listid, int state);\par }
{\li400 Sets or resets the property "column selection" of a list-box. "Column 
selection property" This means that when the user clicks on a row then 
only the clicked column will be highlighted. This may be useful in 
combination with CguiListBoxRowGetClickedColumn. If state is 0 it is 
turned off, else on. By default it is turned off. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v SetListColumns}SetListColumns(int listid, int (*RowTextCreater)(void *rowdata, char *s, int colnr), int *widths, int n, int options, char **labels, void (*CallBack)(void *data, int id, int i), void *data);\par }
{\li400 This function partitions the list into `n' columns. Note that this 
`RowTextCreater' will replace the one previously passed in the call to 
AddList, so you may as well just pass NULL when adding the list to the 
window. Texts longer than specified column will be clipped.\par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  listid: the id-key of the list to be partitioned into columns 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  RowTextCreater: Pointer to a callback-function written by you. This 
function will be called once per column, and is supposed to produce 
the text that are wanted for that column on that row.\par \pard \li800 \pard \li800 
RowTextCreater works analogus as the `RowTextCreater' that may be 
specified in the call to AddList, but it will also get the column 
number. The return value is only inspected for column 0 (see AddList 
for details).\par 
Parameters to RowTextCreater: 
\par {\li1200 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  rowdata: the data created by you `index' or `linked list' 
function specified by IndexCreator. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  s: Pointer to an array where `RowTextCreater' shall put the 
text-string. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  colnr: The column number to which the text shall be created 
the first column is 0 
\par}\pard \li800 \pard \li800 \pard \li800 \pard \li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  widths: An array of column widths. The pointer must point to `n' 
integer values that must be in persistent memory (i.e. static or 
dynamic). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  n: number of columns 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  options: The following options are currently available (pass 0 if you 
don't need any option): 
\par {\li1200 \pard \li1200 \pard \li1200 \pard \li1200 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  LIST_COLUMNS_ADJUSTABLE: Lets the user change the width of the 
columns using the mouse. The values pointed to by `widths' will be 
properly updated. The listbox will adapt its width to be at least 
the width of all the column. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  LIST_COLUMNS_ADJUSTABLE_KEEP_BOX_WIDTH: Like the above option, but 
will not allow the total width of the columns to be more than the 
width of list box. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  LIST_COLUMNS_DELIMITER: Tells that there will be drawn vertical 
lines as delimiters between the columns (or rather at the right end 
of each column). 
\par}\pard \li800 \pard \li800 \pard \li800 \pard \li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  labels: an optional array of pointers to strings of labels. Pass 
NULL if you don't need them. NOTE! In contradiction to the 
convention in CGUI, in this case both the array and the strings 
needs to be in persistent memory. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  CallBack: An optional pointer to a function written by you (if you 
don't need it you can just pass NULL). This function will be called 
when the user clicks on the label-button of a certain column. You 
may use this e.g. to let the user sort the objects in the list. 
Parameters to `CallBack': 
\par {\li1200 \pard \li1200 \pard \li1200 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  data: the pointer `data' passed to SetListColumns 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  id: the id number of the column label itself. This may be used 
e.g. to obtain the mouse-button used. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  colnr: the index of the column (the leftmost is 0). 
\par}\pard \li800 \pard \li800 \pard \li800 \pard \li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  data: a pointer to any data (this will be passed to `CallBack' when 
it is called) 
\par}\par}\pard \li0 \par \par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v RefreshListRow}RefreshListRow(int id, int i);\par }
{\li400 If you only need to update one row of a list, and know the index of your 
data, a call to "RefreshListRow" will do that for you. 
UpdateListRow will not update the scroll-buttons or the browse-bar. 
\par \par Returns 0 if id is not a list reference otherwise 1 
\par \par Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  id: a reference to a list, if id doesn't refer to a list, the 
request will be ignored 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  i: index to the data that shall be updated. If "i" is currently not 
in the visible part of the list-box or if it is out of range, then 
the request will be ignored. 
\par}\par}\pard \li0 \pard \li0 \par \par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v BrowseToF}BrowseToF(int id, int i);\par }
{\li400 The data with the index 'i' will be selected (highlighted) and viewed as 
the first (top) row of the list-box. 
If 'i' is out of range then either index 0 or the highest possible index 
will be chosen instead. 
\par \par If the list exists returns 1 else returns 0. 
If `id' refers to list within a chain of lists, the browsing will 
affect all the lists in chain where "listid" exists. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v BrowseToL}BrowseToL(int id, int i);\par }
{\li400 The data with the index 'i' will be selected (highlighted) and viewed as 
the last (bottom) row of the list-box (or as the last row of the list if 
the list contains less data items than there are rows in the list). 
If 'i' is out of range then either index 0 or the highest possible index 
will be chosen instead. 
\par \par If the list exists returns 1 else returns 0. 
If `id' refers to list within a chain of lists, the browsing will 
affect all the lists in chain where "listid" exists. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v BrowseTo}BrowseTo(int id, int i, int uncond);\par }
{\li400 The data with the index 'i' will be selected (highlighted) and the 
list will, if necessary, be browsed to make i come in view. 
\par \par If 'i' was "above the top" of the list-box prior to the call then 
it will be the top row after. 
\par \par If 'i' was "below the bottom" of the list-box prior to the call 
then it will be the bottom row after. 
\par \par If 'i' is already viewed in the list-box, then it will just be focused. 
In this case you maybe want the entire list-box to be unconditionally 
re-drawn (e.g. to make sure that some of your re-sorting or other updates 
are correctly reflected), then set 'uncond' to true. 
\par \par If the list exists returns 1 else returns 0. 
\par \par This function may be used not only for browsing, but also for 
re-selecting or pre-selecting a specific row in a list that you want to 
set focus on. If 'id' refers to list within a chain of lists, the 
browsing will affect all the lists in chain where "listid" exists. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v SetListGrippable}SetListGrippable(int listid, int (*Grip)(void *srcobj, int reason, void *srclist, int i), int flags, int buttons);\par }
{\li400 \par \par Defines the list-rows in a list to be Grippable. 
\par \par Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  listid: a reference to a list 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  button: specifies which mouse button(s) that are allowed for 
gripping 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  flags: see: SetObjectGrippable. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  Grip: a call-back function that will be called in the following 
cases: 
\par \pard \li800 \pard \li800 \pard \li800 \pard \li800 \par Grip will always be called when the mouse cursor goes over the row, 
the "reason" will then be DD_OVER_GRIP. Grip must at this call 
determine if it accepts to be gripped, and in that case return 
1 otherwise 0. If returned 1 the object may later be gripped 
(without notification) and possibly later on also be dropped. 
\par \par If the "row was gripped" and later on dropped successfully on some 
other object (must not necessarily be a list-row), then Grip will 
be called a second time and the "reason" will now be DD_SUCCESS. 
The return value of Grip will be ignored this time. The recipient 
(the object on which was dropped) has already been called when Grip 
is called. 
\par \par The parameter "srcobj" is the object pointer of the gripped row, 
i.e. the pointer created by the `ApplicationDataAtIndex' of the 
list of the gripped row. 
\par \par The parameter "srclist" to the call-back function will be the same 
address as "list" (the pointer previously passed to the 
AddList-function), "i" will be the index of the gripped object in 
the "list"-data. 
\par}\par}\par \par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v SetListDroppable}SetListDroppable(int listid, int (*Drop)(void *destobj, int reason, void *srcobj, void *destlist, int i, int flags), int flags);\par }
{\li400 Defines the list-rows in a list-box to be drop-able. 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  listid: a reference to a list 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  flags: see: SetObjectGrippable. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  Drop: a call-back function that will be called in the following 
cases: 
When the mouse cursor is dragged over a list row 
carrying a gripped object, the "reason" will then be DD_OVER_DROP. Drop must 
at this call determine if it accepts to be dropped on, and in that case 
return 1 otherwise 0. If returned 0 there will be no more call concering 
the same row until next time the mouse goes over the edge of that row from 
outside of it. 
\par \pard \li800 \pard \li800 \pard \li800 \par If, on the other hand, the gripped row has been successfully dropped, Drop 
will be called a second time and the "reason" will then be DD_SUCCESS. The 
return value from this call will be ignored. The gripped row will be 
notified later on about the successful drop. 
\par \par The parameter "destlist" passed to Drop will be the same address 
as "list" (the pointer previously passed to the list-creation function), 
"i" will be the index in the list and reason will be either of DD_SUCCESS 
or DD_OVER_DROP. 
\par \par The parameter "srcobj" is the source (the gripped) object, just 
transferred from a Grip-function. This must not necessarily be an object 
in another list. 
\par \par The parameter "flags" passed to Drop is the "and"-ed result of the flags 
for the gripped and dropped object. This has already been examined and 
will always be non-0, i.e. the drag-drop operation is legal according to 
your specification. The flag-variable is only passed as an extra info. 
\par \par The parameter "destobj" is the object pointer of the dropped row, i.e. 
the pointer created by the `ApplicationDataAtIndex' of the list dropped on. 
\par}\par}\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v SetListDoubleClick}SetListDoubleClick(int listid, void (*CallBack)(int id, void *data, int button), int button);\par }
{\li400 Sets a list to be double-clickable by installing yet one call back. 
This `CallBack' is analogous to the `Action' that you passed to `AddList' 
for single click call backs. 
See also `SetObjectDouble' for details.\par 
Returns 1 if listid refers to a list, otherwise 0.\par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  listid: a reference to a list. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  CallBack: a function written by you, it will be called when a row in 
the list `listid' is double clicked by the user. Parameters to 
`CallBack': 
\par {\li1200 \pard \li1200 \pard \li1200 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  id: the id of the row object. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  data: the data object of the row item (same as passed to `Action'. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  button: the button that was double clicked. 
\par}\pard \li800 \pard \li800 \pard \li800 \pard \li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  button: the mouse button that shall react on double click (i.e. 
LEFT_MOUSE or RIGHT_MOUSE or both). 
\par}\par}\pard \li0 \par \par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v HookList}HookList(int listid, void *listdata, int *n, int width, int events, int (*RowTextCreater)(void *data, char *s), void (*Action)(int,void*));\par }
{\li400 Lists may be chained together. This means that they are controlled by one 
common browse-bar and common scroll-buttons. This is useful when 
displaying lists containing records with different items and the 
different items need to be individually selectable.\par 
This function hooks a new list to the right of another list. The first 
list must be created with a call to AddList.\par 
The creation of list is not finished until a call to either 
`IterateLinkedListOfApplication' or `ApplicationDataAtIndex' is done, 
see AddList for info about these functions.\par 
Returns the id of the new listbox if listid is valid otherwise 0.\par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  listid: a reference to a list. If there already exists more than one 
list in a chain (i.e. this is second or more call to HookList) then 
any of these listid's may be used as reference - the new one will 
always be put to the right of the previously rightmost one. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  listdata, width, events, RowTextCreater, Action, label: see AddList 
for info about these parameters. 
\par}\par}\pard \li0 \pard \li0 \par \par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v SetDeleteHandler}SetDeleteHandler(int listid, void (*CallBack)(int rowid, void *object));\par }
{\li400 Associates DELETE-key presses to the list "listid". The list will only 
recognise the key-press if is active (in focus).\par 
Returns 1 if listid refers to a list, otherwise 0.\par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  listid: a reference to a list (the return value from AddList shall 
be used) 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  CallBack: a pointer to a function that must be written by you. 
This function will be called when the user wants to delete objects 
from the list by pressing the Delete-key while the row is in focus. 
The parameter "obj" is the address to the 
object to delete (the address calculated by the function 
"IterateLinkedListOfApplication/ApplicationDataAtIndex"). If there 
were multiple rows marked "CallBack" will be called once for each 
marked row. However 'CallBack' can alternatively call 'GetMarkedRows' to 
get them all. 
The parameter 'id' is a reference to the row object. 
\par}\par}\pard \li0 \pard \li0 \par \par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v SetInsertHandler}SetInsertHandler(int listid, void (*CallBack)(void *list, int index));\par }
{\li400 Associates INSERT-key presses to the list "listid". The list will only 
recognise the key-press if is active (in focus). 
\par \par Returns 1 if listid refers to a list, otherwise 0. 
\par \par Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  listid: a reference to a list (the return value from AddList shall 
be used) 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  CallBack: a pointer to a function that must be written by you. 
This function will be called when the user wants to insert a new 
object into the list. The parameter "list" is the "list"-data item 
specified when the list was created. "index" is the focused index 
in "list" that currently in focus. 
\par}\par}\pard \li0 \pard \li0 \par \par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void **{\xe\v GetMarkedRows}GetMarkedRows(int listid, int *n);\par }
{\li400 This function returns a pointer to an array of list-object pointer, those 
that for the moment are marked (blue).\par 
This may typically be of interest in e.g. a callback installed by 
`SetDeleteHandler'. If the user has made a multi-row selection and 
wants to have them all removed it may be nicer to give a message like 
"Remove all this 17 ...?" rather than 17 requests like 
"Remove this..." . \par 
If it fails or if there are no selected items the return value will be 
NULL and the value pointed to by `n' will be set to 0. 
The returned pointer points to dynamic allocated memory, which the caller 
has the responsibility to free when no longer used. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v GetListIndex}GetListIndex(int rowid);\par }
{\li400 This function returns the index of a certain row in a list. 'id' must 
refer to an row-object of a list-box (and will be passed to the callback- 
function of the list-box). 
\par \par If id do not refer to a list-row it will fail and return -1 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v NotifyFocusMove}NotifyFocusMove(int listid, void (*CallBack)(int id, void *rowobject));\par }
{\li400 This functions makes an initialisation so that your program will be 
notified by a call to `CallBack' when a row in a list gets focus. 
\par \par Return value: 1 if successful else 0 (no good listid) 
\par \par Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  listid: must be a leagal id to a list 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  CallBack: the pointer to a function written by you. This function 
will be called each time a row gets focus (e.g. because the user 
moves the "row-cursor" by use of arrows). Parameters in that call: 
id is the id of the row-object. This may be used to e.g. get the 
row-index by calling GetRowIndex; parameter 'rowobject' is the 
pointer created by your list-index-function. 
\par}\par}\pard \li0 \pard \li0 {\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Tabwindows}Tabwindows\par }
A tab-window is a node within a regular window. 
It consists of the tab-bar (a row of tab-selectors) at the top, and the 
rest of the node which will display different sets of object depending on 
which tab that is currently selected.\par 
The tab-bar is limited to one row of tabs (or "selectors"). These 
actually works similar to radio-buttons, but looks like "tabs". There 
must be at least one tab. Each tab has a text-label.\par 
When the user clicks on a tab, your call-back function associated with 
that tab will be invoked (see AddTab). The point is that the call-back 
function shall create all the objects corresponding to the tab. The 
regular functions for creating objects may be used, which implies the 
possibility of nested tab-windows.\par 
If there is not space enough for all the tabs the excess ones will be 
clipped, which is not as bad as it seems. However: The main point with 
tabs-windows is to make quick access to the different controls, and this 
is not not fulfilled anyway if you add too many tabs. 
\par \par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v CreateTabWindow}CreateTabWindow(int x, int y, int width, int height, int *status);\par }
{\li400 Creates the node object of the entire tab-selector. Returns object-id.\par 
Return value is the identification key for the entire tab-window 
(including the tab bar at the top).\par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  x1, y1: position for the tab-window 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  width, height: the size of the tab-window (may also be ADAPTIVE). 
status - should point to a variable that contains the index of the 
currently selected tab starting with 0 for the leftmost one. May be 
used by your program to restart anther time with the same selection 
as when closing. 
\par}\par}\pard \li0 \pard \li0 \par \par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v AddTab}AddTab(int id, void (*callback)(void *data, int id), void *data, const char *label);\par }
{\li400 Adds one tab into the bar of tabs in a tab-window. The callback, which is 
a function you must code, will be called when the tab is clicked by the 
user or initially by DisplayWindow(). The callback is not supposed to 
open a new window. The only thing it shall bother about is to create the 
objects for the tab-subwindow. This has always been cleaned before 
callback is invoked (i.e the objects created by a previous selection has 
been removed before call). The callback shall not refresh the objects in 
the tab-window, this will also be done automatically after return.\par 
All objects created by the callback will be but in the tab-window. 
If absolute co-ordinates are used for such objects (x,y) these shall 
refer to the upper left corner of the free area in the tab-window.\par 
Like other objects tabs may be added also after the window has been built 
with a call to DisplayWin. The same applies to removal of tabs.\par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  id: The id-code previously returned by CreateTabWindow 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  label: This is the label that will be displayed on the tab. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  data: A pointer to any data that you want to be passed to your 
callback each time it is called. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  callback: A pointer to a function that you have written. It will 
be called by CGUI when needed. That is when the user clicks on the 
tab or when CGUI wants to draw the content of the tab for some other 
rason. Your function shall create the objects that you want to appear 
in this tab window when this tab is clicked. This function is called 
in a context that makes it impossible to destroy the dialog of the 
tab window. 
\par \pard \li800 \pard \li800 \pard \li800 \pard \li800 \par \par Parameters to callback: \par 
data: The pointer `data' passed to AddTab 
id: The id to the tab itself (not the container with the objects). 
This can be used e.g. to remove the tab or to check which of the mouse 
button that was used. When a tab is removed the next tab will be 
selected. If there is no next tab the previous tab will be selected. 
The behaviour when removing the last tab is undefined. 
\par}\par}\par \par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v HookLeaveTab}HookLeaveTab(void (*callback)(void *data), void *data);\par }
{\li400 This function registers 'callback' to be a function that will be called 
with 'data' when a tab in a tab-window is left. The tab will be left 
either because the user selects some other tab in the same tab-window or 
because the entire window is closed.\par 
HookLeaveTab must be called when generating the tab-window (i.e. by the 
function installed by 'AddTab'), only at this stage the tab-window is 
prepared to receive such a call.\par 
The purpose is to give your program the possibility to release memory 
that you needed to allocate for the objects in the tab-window. 
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Hotkeys}Hotkeys\par }
A "hot-key" means that a key pressed by the user invokes a function call. 
Creating hot-keys may be done in following four ways: 
\par {\li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  By marking a single character (by preceding it with the 
tilde '~' character) in the label text of a visible object. This 
character will then be the hot-key for clicking that object. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  Implicitly when the system automatically generates a hot-key for an 
newly created labelled object (DisplayWin does this). These hot-keys 
will always be selected from, so far, unused keys. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  Explicitly assigning a hot-key to an object (or extending the object 
with yet one). This will be done by use of the "#scan,ascii;" 
command in the label string. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  Explicitly creating a "hot key" for any purpose (not associated with 
any visible object) by call to SetHotKey. 
\par}\pard \li0 \pard \li0 \pard \li0 \pard \li0 \par Hot-keys associated with an existing object will be automatically removed 
when the object is removed (which normally will be done when closing the 
window).\par 
Hot-keys created with SetHotKey will be removed when the node which it is 
associated with, are removed. Such hot-keys may also be removed 
selectively by just calling Remove and pass the id received from 
`SetHotKey'.\par 
When assigning hot-keys explicitly there is no check if the key is 
already used. If the same hot-key is assigned to multiple objects, it is 
not defined which one will be selected when the user presses the key. 
You may use the function IsHotKey to avoid ambiguous 
hot-keys.\par 
The scope of hot-keys is normally a window. An exception from this are 
menus which have their own scope...or to be correct: this is no exception 
since menus are implemented as windows... Tab windows are not independent 
windows, and the objects in "hidden tab-windows" does not exist, so there 
will be no conflict if same keys are used in different 
tab-windows.\par 
A special hot-key feature is the tab-chain. Any number of objects may be 
linked together in the tab-chain. There is one tab-chain in each window 
(possibly empty). Selectable objects (i.e. such objects that are used 
for user input) will automatically join the tab-chain when they are 
created. \par 
The tab and back-tab keys are reserved for the tab-chain. One of the 
objects within the chain are pre-set to be in 
"tab-focus" when the window is created (by default this will be set to 
the first one in the chain). When the user presses the tab or back-tab 
key the "tab-focus" will move to the next or previous object in the 
chain.\par 
The "tab-focus" means that the object is highlighted, and that it will 
catch subsequent ENTER and/or CRTL-ENTER key presses. The ENTER-key 
matches left mouse-button and CTRL-ENTER right mouse-button, so the later 
requires the object to be pre-set to receive right mouse clicks.\par 
The chain is circular. An object in the tab-chain that is currently 
deactivated will not get the tab-focus, it will be by-passed if reached 
by a tab key-press. \par 
The order in which the object joins the tab-chain controls their position 
in the chain. By default the joining is their creation order.\par 
Containers may also join the tab-chain (optionally). The effect is that 
the container itself will take one position in the chain. While the 
container is in "tab-focus" any object within it may be in "sub-focus", 
which in this case is the real focus notified by the user and sensible for 
enter/ctrl-enter. The user can move the sub-focus only by using the 
arrow-keys. This requires that the objects within the container are 
grouped and positioned in a tabular manner (the sub-focus will go the 
object next to left/right/below/above following the x/y-coordinate of 
the current sub-focused object. This implies that it will not work 
properly if there are containers nested within the one joining the 
chain, only one level is possible.\par 
If an object within the tab-chain is selected by use of the mouse (e.g. 
if it is clicked), then the focus is moved to it.\par 
There are functions to re-arrange the default order in the tab-chain, 
to force the focus to some object and to achieve info about which object 
that is currently in focus. 
\par \par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v AutoHotKeys}AutoHotKeys(int mode);\par }
{\li400 Possible modes: 0 (turn off) or 1 (turn on)\par 
In default mode CGUI will automatically try to generate short-cuts 
for text-labelled visual objects. With this function you can alter that 
mode. You may need this e.g. when you use text chosen by the user for 
labels and the number of labels can be quite large. In such case the 
time to calculate which letters that are unique can be quite long, or 
in worst case infinite.\par 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v JoinTabChain}JoinTabChain(int id);\par }
{\li400 When objects like buttons, check-boxes, list-boxes etc are created they 
will automatically be linked into a `tab-chain' (strict sequential and 
flat in the tree-formed window). The tab-chain defines 
which objects that may be set in focus by the user (using the 
tab/backtab keys) and it also defines the order between these objects. 
The order of the automatic joining will be the order in which the objects 
were created.\par 
You can use `JoinTabChain' to add objects that do not join the chain 
automatically (e.g. canvas-objects) or to customise the order between 
them by re-joining.\par 
Not only simple objects like buttons can join the tab chain, but also 
containers (e.g. radio-containers, list-boxes etc.). If the user tabs to 
a container the selection of a certain object within the container can be 
done by use of the arrow-keys. It is not meaningful to join a container 
in which there are more containers (i.e. recursive constructs), since 
there is no way for the user to control the focus movement within the 
sub-sub-container.\par 
`JoinTabChain' will first remove the object `id' from the chain if it is 
already there, and then insert it after the currently focused object. 
The focus is not changed.\par 
Returns 1 on success and 0 if it fails. The parameter `id' shall be the 
id-key of an object (returned by the creating function). 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v SetFocusOn}SetFocusOn(int id);\par }
{\li400 When a window is created the first created object within the window that 
joins the tab-chain will be in focus. The meaning of "beeing in focus" is 
that it will be drawn highlighted in some manner and it is ready for 
input. For simple objects like buttons, check-boxes etc. this means that 
a subsequent enter key-press will have the same effect as a click. For 
edit-boxes it means that it is ready to let the user type in text (the 
text-cursor is blinking). For nodes like menu-bars, radio-containers, 
list-boxes etc it means that the user may make a sub-selection of an 
object with use of the arrow-keys.\par 
This function explicitly sets the focus on the object `id'. It must be 
a selectable object (i.e. it must be in the tab-chain). 
You can call `SetFocusOn' immediately after you finnished the window 
building process by a call to `DisplayWin', or later to e.g. highlight a 
newly performed action by the user. \par 
`SetFocusOn' updates the view of both the previus and new focus.\par 
There are some different cases of the object `id': 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  `id' is a simple object: The focus is moved to it (and the 
previously focused will be unfocused). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  `id' is a node (container) that has joined the chain: The 
the main focus is moved to the node (which normally has no special 
view) and the simple object within the node that was last in 
"sub-focus" will now be highlighed as `focused'. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  `id' is an object within a node (container), and the node itself 
is the one that has joined the chain: The 
`tab-focus' will be moved to the node and `id' will be highlighted. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  `id' is a window: The window will get the focus in case 
there are no modal windows above it (highligted in the header). 
\par}\pard \li400 \pard \li400 \pard \li400 \pard \li400 \par Returns 1 on success and 0 if it fails. \par 
The parameter `id' can be the id-key of any type of object (returned by 
the creating function). 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v GetCurrentFocus}GetCurrentFocus(int id);\par }
{\li400 Returns the id-key of the object that is currently in focus. \par 
If `id' is 0 the id-key of the window currently beeing in focus will be 
returned.\par 
If `id' referes to a window then the focused object within the tab-chain 
of that window will be returned. \par 
If `id' referes to a container that has joined the tab-chain, the focused 
(simple) object within that container will be returned. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v SetHotKey}SetHotKey(int id, void (*CallBack)(void*), void *data, int scan, int ascii);\par }
{\li400 Installs an application-specific handler which will be called with "data" 
when the user presses the "hot-key".\par 
This "hot-key" will be hooked to any container, and it will be removed when 
the container is removed.\par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  id: the id-key to the container (or window, tab-window, list, container etc) 
To get a hot-key that is global (and permanent) for all windows, 
just enter 0. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  CallBack: a function written by you. It will be called when a 
key-press matches scan, ascii that you specify. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  data: passed to CallBack 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  scan, ascii: specifies the hotkey. The case of ascii letters are 
is ignored when matching with the actual key press. The format 
should be the same as for the value returned by Allegro's 
function readkey(). 
\par}\par}\pard \li0 \pard \li0 \pard \li0 \pard \li0 \par \par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v IsHotKey}IsHotKey(int scan, int ascii);\par }
{\li400 Checks if the specified scan/ascii already has been used in the 
operating window.\par 
Returns 0 if not, otherwise 1 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v SimulateHotKeys}SimulateHotKeys(int scan, int ascii);\par }
{\li400 This function calls for the system's handler of hot-keys, which is 
by default the receiver of keys (if no editbox is in focus), and does not 
normally need to be called by the application program.\par 
SimulateHotKeys will have the same effect as if the user pressed the 
specified keys. This function may possibly be useful to call in 
special cases in some other keyboard-handler (to bypass the let the 
key-presses bypass the current keyboard- handler (and all other) and 
go directly to the hot-key handler. Another way of doing this is to 
call Allegro's `simulate_keypress'. This will however lead to a new 
entry in the event queue. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v UseHotKeys}UseHotKeys(char *hkset);\par }
{\li400 Specifies which characters in the labeltexts that shall be used by the 
system when the automatic generation of hot-keys is in progress. Default 
is the english alphabet. If you wants national characters or special keys 
like %-/ etc to be candidates for hotkeys then use this function. `hkset' 
will replace the previous set. 
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Events}Events\par }
The event processing in CGUI will be started by a call to ProcessEvents 
stopped by a call to StopProcessEvents. Typically ProcessEvents is called 
at beginning of your program (after InitCgui and after making it possible 
for the user to generate some events by e.g. creating a 
window).\par 
A typical external event is a mouse event. A mouse event may serve as an 
explanation to what actions are taken when an event occures 
\par {\li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  the user made something with the mouse (moved, pressed button etc) 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  the processor recieved an interrupt 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  Allegro captures this and calls CGUI's interrupt handler 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  CGUI's interrupt handler will put this mouse event into the queue of 
messages together with a reference to CGUI's mouse processor 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  CGUI's event processor will later on find the message in the queue 
and will launch the call-back found in the message, which in this 
case happens to be CGUI's mouse processor 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  CGUI's mouse processor will pass the message to the window in focus, 
which in turn will pass it to its predecessors: the objects in it. 
If the mouse-event matches the conditions for the actions of some 
object it will perform the action of the object. Typically a click 
on a button will lead to the action of invoking the call-back 
function that you passed to the `MkButton'. 
\par}\pard \li0 \pard \li0 \pard \li0 \pard \li0 \pard \li0 \pard \li0 \par It works in a similar manner with hot-keys. 
Sometimes you may want things to happen later on. For that purpose you 
may explicitly generate an event with some delay (this may be used in 
animation). The call GenEvent(foo, bar, 0); is equivalent to the call 
foo(bar); at end of the function that calls GenEvent (provided that the 
event queue is empty). 
\par \par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v ProcessEvents}ProcessEvents(void);\par }
{\li400 Start event processing. This function will not return until 
StopProcessEvents has been called. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v StopProcessEvents}StopProcessEvents(void);\par }
{\li400 Stop event processing. You shall call this function in the call-back 
function where you want CGUI to stop the event handling, e.g. 
in the call-back for a button "Exit". In a typical gui-program you don't 
need to call for StopProcessEvents, if you prefere you can call exit(), 
instead. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b unsigned {\xe\v GenEvent}GenEvent(void (*Handler)(void*), void *data, unsigned delay, int objid);\par }
{\li400 Generates an event, i.e. adds one messages to the event queue. 
The effect of calling 
\par {\s1 \f1\fs18 
\par    GenEvent(my_function, mydata, 0, 0);
\par    is
\par    my_function(mydata);
\par    \par}if the event queue happens to be empty. The purpose is to serialize the 
work to be done (i.e. let some processing be finished before invoking the 
function in concern), or to ensure that some events that may be in the 
queue will be processed prior to your function. 
Another purpose is to achieve that the function will be called after a 
certain amount of time.\par 
Return value: An event id. Event ids are not the same as the ids of 
window objects. There can never be two events with the same id, and 
there can never be two window objects with the same id, but a window 
object may occasionally have the same id as an event id.\par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  Handler: The call-back function (probably written by you) that you 
want to be called. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  data: a pointer to some of your data that `Handler' needs to be 
called with. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  delay: a delay time in milliseconds. The delayed queue is 
implemented as a separate queue, so what is really done is that 
when a timer expires, the messege will be moved from the delayed 
queue into the end of the queue of current events. If some 
processing is in progress and/or some messages was already there 
in the message queue all these prosessing must be finished before 
the delayed message will actualy start executing. Most of the time 
the queue is empty. The accuracy of time measurment is one unit of 
the time resolution provided by Allegro, but as best 1 ms (i.e. a 
delay time specified as 5 ms on a DJGPP system will be delayed in 
the range of 4 to 5 ms, depending on what delay it happens to be 
until next tick). Just pass 0 if you don't want the message to be 
delayed. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  objid: An optional (pass 0 if you don't need it) reference to an 
window-object. In some cases you may get obscure bugs in your 
application if your queued messages refers to data or window-objects 
that don't exist any longer. You can avoid such dangling references 
by killing the queued event message at proper time (i.e when the 
data is about to be destroyed). Often you will find it easier to set 
a link from the event to the object that it depends on. It will then 
be destroyed, with the object. 
\par}\pard \li400 \pard \li400 \pard \li400 \pard \li400 \par Return value: an id that identifies the event, greater than zero, or 0 
if it fails (that is: if the event queue has been stopped because of a call 
to `StopProcessEvents'). 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v KillEvent}KillEvent(unsigned eventid);\par }
{\li400 Removes specified event from the event queues. Returns the true if 
the message was there.\par 
Only events generated by your program can be killed. Events generated 
bu CGUI itself are protected.\par 
Returns 0 if the event was not found, else non-0. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v FlushGenEvents}FlushGenEvents(void);\par }
{\li400 Removes all events generated by previous calls to the function GenEvent 
from the event queue. Events generated 
bu CGUI itself are protected. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v CguiEventIterateFunction}CguiEventIterateFunction(int (*Function) (void *data), void *data);\par }
{\li400 Will iterate `Function' (using the event queue) until it returns 0. This 
can be used e.g. if you want to run a game on top of CGUI, for example in 
a window so that mouse and key events of CGUI are still processed. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v CguiYieldTimeslice}CguiYieldTimeslice(int state);\par }
{\li400 By default the event loop of CGUI will yield a timeslice to the system 
between each two checks for new events. This is to avoid that you CGUI 
program takes almost all available CPU power. This may slow down your 
program in some context. If you want to turn off the yielding of 
timeslices then call this function with 0, to turn it on again call it 
with non-0. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v InstallKBHandler}InstallKBHandler(int (*Handler)(void *data, int scan, int key), void *data);\par }
{\li400 Installs a key-board handler. This handler will be called for each key 
pressed by the user.\par 
For "normal" programming of an application this is not needed. By default 
the hot-key handler will be installed by InitCgui. When an edit-box 
will be selected for input by the user it will install a keyboard 
handler for the edit-box - this one overrides the hot-key handler. 
I.e. all subsequent key-presses will go to the key-board handler of the 
edit-box instead of the key-board handler of the hot-keys.\par 
The call-back function "Handler" should return a non-zero value if the 
key is accepted. A rejected key will be passed to next keyboard-handler 
on the stack of keyboard handlers.\par 
The pointer "data" will be transparently passed to the handler when 
invoked, together with scan-code and ascii-code. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void *{\xe\v UnInstallKBHandler}UnInstallKBHandler(int (*Handler)(void *, int , int ));\par }
{\li400 Removes the a keyboard-handler previously installed by InstallKBHandler. 
Also handlers not on top of the stack may be removed. 
Return 0 if the specified handler is not present. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v Invite}Invite(int mask, void *data, char *text);\par }
{\li400 Meetings is a mechanism that makes a kind of "hand-shaking" possible. It 
will make it possible to simulate "process-like" objects, which may be 
used in communication protocols.\par 
About meetings: Any of your functions may invite to a meeting, which 
means that its execution will be held (within "Invite"). The only way for 
the function to continue is that an event occurs and the callback of that 
event calls for "Attend" with a matching mask. 
Until Attend has been called, other events will be properly processed. 
Invitations are stack-based, which means:\par 
If, while one invitation is open, another call-back "invites" to a 
new meeting, then that later of the invitations has to be attended (by 
anyone) before the event system will try to match any attendings to the 
first of the invitations. 
\par {\s1 \f1\fs18 
\par    ________
\par    | 0x8  | last invite
\par    --------
\par    | 0x80 |
\par    --------
\par    | 0x2  |  first invite
\par    --------
\par    \par}In the figure above all "attendings" with mask 0x80 and 0x2 will fail 
until the meeting with mask 0x8 has been finished.\par 
Return value: always 1\par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  mask: the meeting is identified by this bitmask (mask from invite 
and attend will be anded, and a non-zero is regarded as a match) 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  text: an identification text (n.u.) 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  data: a pointer to any data that may be updated or read by the 
"attending" function. 
\par}\pard \li400 \pard \li400 \pard \li400 \par Return value is 1 (it will always succeed). 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void *{\xe\v Attend}Attend(int mask);\par }
{\li400 Will attend a meeting invited to by function `Invite' if parameter `mask' 
matches the meeting. 
Return value: Attend returns the pointer "data" passed by `Invite' if 
successful meeting, otherwise NULL. 
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Misc}Misc\par }
Various functions that may be of interest. 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b char const*const*{\xe\v LoadTexts}LoadTexts(const char *fn, const char *section);\par }
{\li400 Loads a section of text from a file. Intended to be used in conjunction 
with the `mktext' tool to make executables language independent 
in an simple way. See readme.txt for `mktext'. The "text module" doesn't 
really do very much, but it does it the right way... 
LoadTexts will search for the language specified in the current 
environment (i.e. allegro.cfg if no other specified). It will first 
search for the language in the CGUI-section, if not found it will look 
in the global section, and if not found there (or if config is not 
present) it will take english.\par 
If the language determined this way is not found in the specified file 
it will look for the english language, and if that is not found it will 
take a random (first).\par 
The language name specified in the text-source may be any text (in legal 
identifier form), strings will just be compared. To make use of the error 
handling you it is necessary to follow the convention used in allegros 
cfg-file (i.e. "en" for english, "de" for german etc). 
`LoadTexts' returns a pointer to an array of strings. That array must be 
indexed with the macros that you specified in the source-file, and 
available in the header-file (`*.ht'), generated by 
`mktext'.\par 
Calling `LoadTexts' requesting an already loaded section, will not 
consume memory (the same pointer as the first time will be returned). 
Calling `LoadTexts' requesting an already loaded section, but with a new 
language found in the current environment, will re-load the text. All 
previously returned pointers to sections within the same file will then 
be corrupt, and must be re-loaded.\par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  fn: filename to load 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  section: the name of the section 
\par}\par}\pard \li0 \pard \li0 \par \par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v DestroyTexts}DestroyTexts(void);\par }
{\li400 Will release memory allocated for all texts loaded by LoadTexts. You 
don't need to call it - it will be called automatically at program exit. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v RegisterConversionHandler}RegisterConversionHandler(void (*Handler)(void *, char *), void *data, const char *name);\par }
{\li400 Registers `Handler' and `data' as the converter for conversion-code 
`name'. `Handler' will be assicated with the text string `name' and 
called with `data' and a string pointer when needed. Its only task is 
to put some text into the string called with, possibly with use of the 
pointer `data'. The `name' shall include the <> like: "<person>". 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v PrintFloatingConversion}PrintFloatingConversion(char *dest, const char *src);\par }
{\li400 A text specified in the source text-file, processed by `mktext' may 
contain conversion codes of an extended format. These codes look like 
%<text> (where `text' may be any text) and may be embedded in the 
source-string like the C-standard conversion codes. The difference is 
that since the conversion is name-referenced multiple occurances of 
conversion codes in the same string may be put permutated order in 
different languages.\par 
`PrintFloatingConversion' does not recognise the C standard conversion 
codes.\par 
If a no handler is associated with the "<xx>" in "%<xx>" (which 
may be the case if you accidently misspell the text), the text 
"<xx>" will be printed instead.\par 
Example: Suppose that the row is in you source-text-file: 
\par {\s1 \f1\fs18 
\par     SIZE_ERROR_TEXT "%<name> has to many (%<nr_things>) things|OK"
\par    \par}Suppose the following fuctions beeing registered for "<name>" 
and "<nr_things>": 
\par {\s1 \f1\fs18 
\par    void name_handler(void *data, char *s)
\par    \{
\par       /* suppose data points to a string containing the desired name */
\par       strcpy(s, data);
\par    \}
\par 
\par    void thing_handler(void *data, char *s)
\par    \{
\par       int *i = data;
\par       /* suppose data points to an integer containing the desired value */
\par       sprintf(s, "%d", *i);
\par    \}
\par    \par}The above functions will be called whith a pointer to proper location 
into the destination string when needed while `PrintFloatingConversion' 
is executing in the below statement: 
\par {\s1 \f1\fs18 
\par    char string[1000];
\par     . . .
\par    PrintFloatingConversion(string, txt[SIZE_ERROR_TEXT]);
\par    Req(string);
\par    \par}This call to `PrintFloatingConversion' will result in the following 
string printed by `Req' (imagine the name to be "John Smith" and 
value to be 13): 
\par {\s1 \f1\fs18 
\par    John Smith has to many (13) things
\par \par}\par    \par}\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b char *{\xe\v msprintf}msprintf(const char *format, ...)\par }
{\li400 This function works as sprintf, except that the print buffer is not an 
input parameter, but instead a return value. The returned pointer is 
allocated dymanically and the caller is responsible for freeing the 
memory. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v CguiUseIcons}CguiUseIcons(const char *filename);\par }
{\li400 Use this function if you want to use other than the default icons for the 
built in dialogues in CGUI. 'filename' must be a dat-file, and the 
datafile objects (i.e. the icons) must be named exactely as in the 
default icons which you can find in the resource directory. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v NameCase}NameCase(char *text);\par }
{\li400 This function converts one string to lowercase, except from the initial 
letter of each word. A word is a sub-string that follows a space, a tab, 
or a minus-sign '-'. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v CguiSetMouseInput}CguiSetMouseInput(void (*MouseInput)(int *x, int *y, int *z, int *buttons), void (*ForcePos)(int x, int y), void (*SetRange)(int x, int y, int w, int h));\par }
{\li400 This function changes the default mouse input, which is the Allegro mouse 
driver, to whatever source you like. This can be useful e.g. in an 
embedded system where a mouse is not present, and you may want to provide 
mouse control anyway, e.g. whith the help of a joystick. 
If MouseInput is NULL the default input handlers will be re-installed. 
\par \par \par Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  MouseInput: A pointer to a function that will be called whenever CGUI 
needs to know the current state of the mouse. MouseInput will never 
return a value outside of the range specified by SetRange. 
\par \pard \li800 \par \par Parameters to MouseInput: 
\par {\li1200 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  x, y: Pointers to locations that MouseInput will update with the 
current position of the mouse. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  buttons: A pointer to a location that MouseInput will update with 
the current state of the mouse buttons. Bit 0 is left mouse, 1 is 
right and 2 is the mouse wheel. 
\par}\pard \li800 \pard \li800 \pard \li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  ForcePos: A pointer to a function that will be called whenever CGUI 
need to force a new position of the mouse. 
\par \pard \li800 \par \par Parameters to ForcePos: 
\par {\li1200 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  x, y: The new position of the mouse. 
\par}\pard \li800 \pard \li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  SetRange: A pointer to a function that will be called whenever CGUI 
need to change the area within which the mouse can move. 
\par \pard \li800 \par \par Parameters to SetRange: 
\par {\li1200 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  x, y, w, h: The new area. 
\par}\par}\pard \li400 \pard \li400 \par \par \par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v AddClock}AddClock(int x, int y, int options);\par }
{\li400 Creates a clock at desired position. The time is shown as HH:MM:SS or 
HH:MM. Which one to use is checked in the config-file. If the value can 
not be retrieved from the config file the default is HH:MM. 
The user can start a dialogue (if not suppressed by flag, see below) 
to adjust the clock settings (minute or second based showing and, in 
case the platform supports it,  modifying the time). User modifications 
are always stored into the current config file.\par 
The `options' parameter can be either of: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  CLOCK_NO_DIALOGUE - The dialogue will not be available for the user. 
\par}\pard \li400 \par The config file to store and read from is the "current config", so if 
you adds multiple clocks they will all get the same setting.\par 
The return value is the id of the clock object. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v Sound}Sound(int freq, int duration);\par }
{\li400 This function is deprecated, use Allegro's functions. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v ScrMode}ScrMode(void (*CallBack)(void));\par }
{\li400 This function will make a dialogue that lets the user select new screen 
settings of resolution and colour depth.\par 
If the changed are done by the user all images that has been 
pre-loaded by `CguiLoadImage', will be re-loaded to make it possible for CGUI 
to display them properly.\par 
After a selection the new settings will be stored into the 
current configuration file. To make CGUI using these stored settings 
automatically, you should pass 0 for the settings when calling InitCgui.\par 
Parameter: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  CallBack: If this parameter is not NULL, the function 'CallBack' 
will be called after the user has made changes. This may be useful 
if you for example wants to store it in some other environment. 
Use the Allegro-macros SCREEN_W and SCREEN_H or 
bitmap_color_depth(screen) to determine the new settings. 
\par}\par}\pard \li0 \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v SaveDatafileObject}SaveDatafileObject(const char *path, void *data, int type);\par }
{\li400 Saves a data file object into an existing datafile.\par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  path: Path pointing into an existing datafile. The path must follow 
the allegro convention for specification of a data file object. i.e. 
[optional absolute or relative path]filename.dat#[optional path 
within the datafile]objectname\par \pard \li800 
The possible "path within the datafile" must exist (sub-datafiles will 
not be automatically added).\par 
If an object with the specified name exists it will be replaced. If 
there are several objects with this name (the datafiles themselves has 
no restriction of multiple names) the first one will be replaced. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  data: a pointer to the data to be stored. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  type: the type of the object to be stored, e.g. DAT_BITMAP. See 
grabber.txt in allegro/tools for more info about data files. 
\par}\pard \li400 \pard \li400 \par Return-value: 0 if error, 1 if ok. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v CreateNewDataFile}CreateNewDataFile(const char *path, const char *filename, int pack, const char *pwd);\par }
{\li400 Creates a new empty datafile.\par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  path: Path the the directory where to create the datafile. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  filename: Then name of the datafile. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  pack: A flag to indicate whether or not the datafile should be packed. 
If non-zero it will be packed. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  pwd: A pointer to a string containing the password in case encryptation 
is wanted, or the empty string if not. 
\par}\pard \li400 \pard \li400 \pard \li400 \pard \li400 \par Return-value: 0 if error, 1 if ok. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v CguiSetColor}CguiSetColor(int color_name, int r, int g, int b);\par }
{\li400 You can use this function if you wish to customize the colors in CGUI. The 
function will only have effect if you call it after the initialization of 
CGUI. 
\par \par \par Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  color_name: You can use any of the following color names, meaning what 
their names suggest: 
\par {\li1200 \pard \li1200 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_DESKTOP 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_UNSELECTED_TAB 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_SELECTED_TAB 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_LIGHTENED_BORDER 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_HEAVY_LIGHTENED_BORDER 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_SHADOWED_BORDER 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_HEAVY_SHADOWED_BORDER 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_CONTAINER 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_WIDGET_BACKGROUND 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_LABEL 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_LABEL_FOCUS 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_LABEL_HIDDEN_FOCUS 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_LABEL_INACTIVE_1 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_LABEL_INACTIVE_2 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_BUTTON_FRAME_FOCUS 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_TEXT_CURSOR 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_DRAGGED_TEXT 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_LISTBOX_TEXT 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_LISTBOX_BACKGROUND 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_LISTBOX_FOCUS_TEXT 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_LISTBOX_FOCUS_BACKGROUND 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_LISTBOX_HIDDEN_FOCUS_BACKGROUND 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_LISTBOX_HIDDEN_FOCUS_TEXT 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_LISTBOX_ROW_DELIMITER 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_LISTBOX_COLUMN_DELIMITER 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_TOOL_TIP_BACKGROUND 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_TOOL_TIP_FRAME 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_TOOL_TIP_TEXT 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_TEXTBOX_TEXT 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_TEXTBOX_BACKGROUND 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_CONTAINER_LABEL 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_EDITBOX_BACKGROUND_MARK 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_EDITBOX_TEXT_MARK 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_EDITBOX_BACKGROUND_INACTIVE 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_EDITBOX_TEXT_INACTIVE 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_EDITBOX_BACKGROUND 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_EDITBOX_TEXT 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_STATUSFIELD_BACKGROUND 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_STATUSFIELD_TEXT 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_PROGRESSBAR 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_PROGRESSBAR_BACKGROUND 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_TITLE_FOCUS_BACKGROUND 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_TITLE_FOCUS_TEXT 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_TITLE_UNFOCUS_BACKGROUND 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_TITLE_UNFOCUS_TEXT 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_TREE_VIEW_BACKGROUND 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_TREE_CONTROL_BACKGROUND 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_TREE_CONTROL_OUTLINE 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_CHECKBOX_MARK_BACKGROUND 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_BROWSEBAR_BACKGROUND 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_BROWSEBAR_HANDLE_BACKGROUND 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  CGUI_COLOR_RESIZER_HANDLE 
\par}\pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  r, g, b: The red, green and blue components of the new color 
\par}\pard \li400 \par If you are using a palette mode (8 bit color depth) the result of the color 
setting depends on Allegro's makecol() ability to find a suitable palette 
index in the palette that you are using. 
\par \par \par The default colors in CGUI are set up at init by loading the values from the 
current config file (i.e. allegro.cfg). If the file is not present or does 
not contain color specifications then internal default values will 
be used. These are the same as those in the config file, meaning that you 
do actually not need to include the allegro.cfg in your distribution 
package. 
\par \par \par The config file loading of start color values provides an 
alternative way to define custom colors, that also let the user control it. 
The names of the config variables are the same as the symbolic names to be 
used for the `color_name'. The values in the file should be given as RGB 
triples (comma separated, no space, decimal notation like e.g. 0,255,255 for 
green). 
Return-value: the previous value of the specified color name, or -1 if the 
color name is out of range. 
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Fonts}Fonts\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v SetCguiFont}SetCguiFont(FONT *f);\par }
{\li400 The CGUI lib contains a font that is used when various CGUI-objects are 
created. You can make CGUI start using your favourite font instead. You just 
need to call `SetCguiFont'. The current set font is assigned to objects when 
they are created, so you can create object with different fonts in the 
same view. Note however that mixing fonts with different heights will cause 
most objects to get different heights, since most objcet types use the font 
height in the height calculation. 
\par \par \par CGUI will not make a copy of the font pointed to by `f', so your program is 
responsible for managing the memory of the font. 
\par \par \par To restore the original built-in font of the CGUI lib you can at any time 
call 'SetCguiFont(NULL)'; 
\par \par \par The rows in list-boxes uses fonts in a different manner, and will not be 
affecte by the call to `SetCguiFont', see details about that in the 
`Listboxes' section. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void FONT *{\xe\v GetCguiFont}GetCguiFont(void);\par }
{\li400 Returns the default font for objects. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v CguiSetBaseLine}CguiSetBaseLine(int base_line);\par }
{\li400 When setting a new font using `SetCguiFont' CGUI will make a guess about 
where the base line of the font is. This will usually succeed for fonts 
conforming to the ususal shape of European letters. However, for odd 
looking fonts, or for non-European fonts it may find a base line that 
does not look good. In such a case you can set the base line explicitly 
after setting the font with `SetCguiFont'. 
\par \par \par The base line is the first empty pixel line below the letters (except 
letters like p, q, g, etc. that breaks the base line). The base line is 
used by CGUI when underlining the letter to be used for short cut selection 
(used in labels of buttons, edit boxes etc. as an alternive to using mouse 
click). 
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Labels}Labels\par }
\par \par A number of objects like buttons, edit-boxes, containers, etc. may have a 
text label. This label may primarly contain the text to be shown on the 
surface of the object in a manner that is useful (e.g. the edit-box will 
put it to the left of the input field, but the container will put it at 
top as a header). 
\par \par The label must not necessarily be static or constant memory, the object 
will make a copy of the text. 
Labelled objects will adapt thier size to the size of the text. 
\par \par The label may be extended with 
additional information. 
\par {\li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  A '~' (tilde) before a letter will make that one to a hot-key. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  A '_' will make a new line (currently only implemented for buttons 
and icons). The '_' itself will not be displayed. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  A control character (ascii code 
as hot-key. This may be useful for attatching hot-keys like 
or  to the object. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  A '#' followed by a numeric value and terminating with ';' 
like "#130;", which will assign the key with ascii-code 130 (0x82) 
to the object. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  A '#' followed by two numeric values separated by a comma and 
terminating with ';' like "#82,1;". The first one will be 
interpreted as the scan-code, and the second the character code 
recieved from Allegro (i.e. a control code for cases of interest). 
E.g. "#82,1;" will assign the shift-insert key-press as hot-key for 
the object. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  Some objects may also contain the "#name;" command. This means that 
an image with the name `name' shall be used to display the object. 
The image may be combined with a text. The image must have been 
previously loaded by the CGUI-function `CguiLoadImage' or 
RegisterImage. Objects that currently recognises images are 
\par {\li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  Buttons 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  Icons 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  Check-boxes 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  Radio-buttons 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  Drop-down boxes (in the label as well as the dropped  down items) 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  Edit-boxes 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  Tags 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  Menu-items (except for radio or check menu items). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  List box rows 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  List box columns 
\par}\pard \li400 \pard \li400 \pard \li400 \pard \li400 \pard \li400 \pard \li400 \pard \li400 \pard \li400 \pard \li400 \pard \li400 \pard \li400 \par \par \par \par There can be up to 3 images specified this way, and they will be 
interpreted in the following way. 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  The first image will be for the normal state. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  The second image will be for the inactive state. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  The third image will be used both for the over and focus states. 
\par}\pard \li400 \pard \li400 \pard \li400 \pard \li400 \par In case only one or two images are present the other states will use 
the image of the normal state. 
\par \par \par Not all widget types will make use of images for all tree state 
e.g. the Tag widget type will not. 
As a consequence that also other kinds of commands are possible to 
embed in the label string, and can start with a "#", you can not use 
image names starting with a digit. A specification of an image 
assigned a name starting with a digit will be parsed as a short-cut. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400  The text string to `Req' has a special format with a leading 
info-text followed by a sequence of at least one button-label, 
all within the same string. The button-labels are indicated by a 
leading '|'. 
\par}\pard \li0 \par If you need to actually draw any of the above control-characters - just 
type them twice in the string. 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v CguiParseLabels}CguiParseLabels(int state);\par }
{\li400 By default CGUI scans labels for certain characters that controls some 
functionality (see above). This may be a problem e.g. if you use file names 
to label some menu items, and the file names occasionally contain characters 
like '~' this will be consumed and the subsequent character will be 
interpreted as a hot-key. 
\par \par \par Therefore you may want to turn off this behaviour. If `state' is zero the 
scanning will stop (all characters will appear exactely as they are). If 
`state' is non-zero it will be turned on again. 
\par \par \par Return value: The previous state of label parsing. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v CguiLoadImage}CguiLoadImage(const char *filename, const char *imagename, int type, int id);\par }
{\li400 This function loads an image with name `imagename' from file `filename'. 
\par Why? - The image as well as its name will be registered in the CGUI 
system which means: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  You may later refer to that image when creating 
objects, i.e. you can use the `imagename' in the label string to 
specify that it shall be the icon used for the widget. Any 
widget type that has a label will support showing images this awy. 
See the section Labels for details. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  When node `id' is destroyed the image will also be - you 
don't need to worry about returning the memory. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  If you let the user change the colour depth by use of the dialogue 
`ScrMode', the images will be converted to the new pixel format (if 
that is possible). 
\par}\pard \li400 \pard \li400 \pard \li400 \par An image associated with a node may be referred from 
objects that are put into that node (at any depth). I.e. if `id' is a 
window, any object put into that window can use that image, or if `id' 
is a container, any object put into that container can use it. Also all 
objects of a sub-window can use the images of a parent window. 
\par If you want to make an image `global' (i.e. it will remain in 
memory until CGUI is shut down), just pass 0 for `id'. 
\par Loading images from 8-bit colour files to a screen mode of 8-bit colour 
will only work properly if all pictures uses one common palette. Loading 
8-bit colour files into high colour or true colour modes will work 
properly only if transparent colour is not used. The same limitation 
applies to the reverse (high -> 8). 
\par In short: to avoid problems use 24-bits files, and at least 
15 bit colour-depth on the screen. 
\par \par \par Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  filename: The path/name of the file that contains the image to load. 
The file-extension may either be any of the types recognised by 
the Allegro function `load_bitmap' or a ".dat". 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  imagename: A string that identifies the image. In subsequent 
references to the image (e.g. when creating a button that shall 
display the image) this name must be used. 
\par \pard \li800 \pard \li800 In case the file is an Allegro-datafile (detected by the 
extension ".dat") the imagename is ignored. The name must be be chosen 
so that it does not conflict with other commands embedded in labels. 
See the section Labels for details. 
\par {\li1200 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  In case of loading a single image from a DATA-file 
the name ending the path will be used as image name (you have to 
use that one as when referencing the image). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  Multiple images can be loaded with a single call, provided that 
they are stored within a datafile at the same nesting level. If 
`filename' is e.g. "my_icons.dat" then all images at the 
top-level of "my_icons.dat" will be loaded, and the image 
names to use is the names of the objects in the data file. If 
`filename' is e.g. "my_data.dat#icons/the_dialog" and 
"the_dialog" is a data-file object of type `DAT_FILE'  then all 
images in that data-file ("directory") will be loaded. The 
meaning of "images" is in this case bitmaps, compiled sprites 
and rle sprites. 
\par}\pard \li800 \pard \li800 \pard \li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  type: This parameter controls if CGUI shall draw a bitmap in 
transparent mode (draw_sprite) or in solid mode (blit). In case the 
image is loded from a datafile and the type of the object is 
COMPILED_SPRITE or RLE_SPRITE the type parameter will be ignored. 
Image type macros: 
\par {\li1200 \pard \li1200 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  IMAGE_BMP: bmp will be handled as a non transparent bitmap. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  IMAGE_TRANS_BMP: bmp will be handled as a transparent bitmap. 
\par}\pard \li800 \pard \li800 \pard \li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  id: The id-key from the node which to hook the image onto. This 
means that when node `id' is destroyed (e.g. because a window is 
be closed) also the image will be destroyed. Typically `id' is the 
id-key of a window. If you want to keep an image during the lifetime 
of the program, just pass 0 for id. If the passed `id' refers to a 
simple object rather than a container or window, the image will be 
hooked into the parent of `id' instead. 
\par}\pard \li400 \par Return value: The id of the node where the image is stored if 
sucessful othewise -1. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v RegisterImage}RegisterImage(void *data, const char *imagename, int type, int id);\par }
{\li400 Works analogous to `CguiLoadImage' but registers an image that is already 
in memory. `RegisterImage' will not make a copy of `bmp' so it must not 
be freed or reallocated as long as it is in use (i.e. as long as object 
id is not destroyed). \par 
In contrary to images loaded from file the registered ones 
will not be automaticallay adjusted when CGUI dialogue for changeing 
the screen settings are used.\par 
The `type' parameter shall be either of the IMAGE_* values 
meaning: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  IMAGE_BMP: bmp will be handled as a non transparent bitmap. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  IMAGE_TRANS_BMP: bmp will be handled as a transparent bitmap. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  IMAGE_RLE_SPRITE: a RLE_SPRITE will be created from bmp 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  IMAGE_CMP_SPRITE: a COMPILED_SPRITE will be created from bmp 
\par}\pard \li400 \pard \li400 \pard \li400 \pard \li400 \par Call `RegisterImage' with NULL for `data' if you want to unregister a 
previously registered image (the name is your handle). You can also 
replace a previous registration by subsequent calls to `RegisterImage' 
using the same name. This can be used to make simple animations on 
objects (which includes plain image objects like those made by `AddTag'), 
see also the examples.\par 
Return value: 0 if it failed (i.e. unknown type, unknown id), else 1. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b const void *{\xe\v GetRegisteredImage}GetRegisteredImage(const char *imagename, int *type, int id);\par }
{\li400 Returns a pointer to an image with name `imagename' in node `id' that 
has previously been registered by `RegisterImage' or `CguiLoadImage'. The 
integer pointed to by `type' will be set to the type of the image, see 
IMAGE_* macros. The type of the returned pointer corresponds to the 
type value. 
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v File bowsing}File bowsing\par }
In CGUI there are two functions for browsing the file system. If you use 
the functions in your program you must link with the libaldat.a library 
located in the lib directory of you Allegro directory. 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b const char *{\xe\v FileSelect}FileSelect(const char *masks, const char *rpath, int flags, const char *winheader, const char *buttonlabel);\par }
{\li400 Opens a file selector dialogue. Simple usage: 
\par {\s1 \f1\fs18 
\par    char *fn;
\par    FILE *filep;
\par    fn = FileSelect("*.txt", "", 0, "Select a file", "OK");
\par    /* fn points to a full path string, the memory will be deallocated by
\par       the file-browser - you must not do. */
\par    filep = fopen(fn, "r");
\par    ...
\par    \par}This function may be useful if your program needs to let the user 
specifiy a file to load, or maybe a filename 
and path to store things in or just to specify a path where the 
program shall put files or seach for files. The user will expect a 
file-browser to behave slightly different in each of these 3 cases. 
You can control its beaviour using the `flags' parameter. 
\par The dialogue is modal (i.e. the parent window of the file selector is 
locked for mouse input until the file-selector has been closed). 
\par The user may browse within Allegro datafiles. 
\par The user closes the dialogue either by use of a cancel-button 
or a confirm-button. If cancel was pressed, the return value will be 
a pointer to an empty string.\par 
Reuturn value:\par 
The return value is a pointer to a string containing the full path to 
the seleceted file (or directory). If an object in a datafile was 
selected it is separated from name of the datafile with the '#' 
character. If the flag `FS_MULTIPLE_SELECTION' is set the user may 
possibly have selected more than one file. If so, each file will be 
enclosed in quotation marks, '"', and separated with semicolon,';' (e.g. 
like "highscore.txt";"readme.txt") and `UnPackSelection' can be used 
to extract single file names from the returned string.\par 
The memory location of the string, is valid only directly after the 
return and belongs to the file-selector, so if you need to use the path 
later on you have to make a copy to save.\par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  masks: A string containing the patterns to search matching files for. 
Multiple masks are allowed: separate with semicolon (e.g. 
"*.txt;*.doc") 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  rpath: Restriction path. The given path is used as an restriction 
for the browsing. The user will be able to browse from the given point 
(witch is always the starting point - the path stored in the datafile 
will be ignored) and downwards, not above it in the directory tree. 
In particular you can restrict the browsing to some Allegro datafile. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  flags: The `flags' variable control some of the properties of the 
browser. Their names and meaning are as follows: 
\par {\li1200 \pard \li1200 \pard \li1200 \pard \li1200 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FS_BROWSE_DAT: Will display Allegro's datafiles as directories 
and lets the user browse them as if they actually where 
directories. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FS_DISABLE_EDIT_DAT: Set this flag if you allow the user to 
browse datafiles but not want him/her to change them and also do not 
allow them to be created. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FS_WARN_EXISTING_FILE: Will warn the user if he/she specifies a 
filename that is already existing. Typically used in store 
operations. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FS_FORBID_EXISTING_FILE: Never give up... 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FS_REQUIRE_EXISTING_FILE: Will only accept a name specification 
that really exist. Typically used in load operations. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FS_SELECT_DIR: When the user selects a directory, that name will 
be put into the name-selection field. If the user instead tries to 
select a file, that operation will be ignored. 
Typically used when the user is supposed to specify a directory 
name. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FS_DISABLE_CREATE_DIR: Don't let the user create directories. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FS_DISABLE_DELETING: Don't let the user delete files or 
directories. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FS_DISABLE_COPYING: Don't let the user copy files or directories. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FS_SHOW_MENU: Shows a menu to the user. The menu contains: 
\par {\li1600 \pard \li1600 \pard \li1600 \pard \li1600 \pard \li1600 \pard \li1600 \pard \li1600 \pard \li1600 \pard \li1600 \pard \li1600 \pard \li1600 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  Check-box: Show the image of an image file or object. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  Check-box: Show the original file name of a data-file object. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  Check-box: Show the file or object time. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  Check-box: Show the file or object size. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  Check-box: Show the file attributes of disk files. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  Check-box: Show hidden and system disk files. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  Check-box: Show the file names case-formatted. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  Selection: Open a file manager. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  Selection: Open a subwindow showing the copy buffer. 
\par}\pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FS_NO_SETTINGS_IN_CONFIG: By default the browser retrievs the 
previous user configuration from the current config-file (and 
stores the new one when closing). Use this flag to suppresse this 
behaviour. The data concerned are: 
\par {\li1600 \pard \li1600 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  The initial path (starting point) when opening. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  Flag telling if the image of an image file or object shall be 
displayed. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  Flag telling if the original file name of a data-file object 
shall be displayed. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  Flag telling if file time shall be displayed. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  Flag telling if file size shall be displayed. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  Flag telling if file attributes shall be displayed. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  Flag telling if hidden/system file shall be displayed. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  Flag telling if formatted case of file-names shall be 
displayed. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  The width of each column in the file-list of the browser. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  The width of the file-list of the browser. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  The height of the file-list of the browser. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  The window position. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  A flag indication if the copy-buffer was opened last time. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  A flag indication if the copy-buffer is in add-mode or not. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  The sorting criterias. 
\par}\pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \par The settings for the file-manager is separated from those of 
the file-selector. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FS_MULTIPLE_SELECTION: Let the user select more than one file. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FS_NO_DRAG_DROP: Disables the feature of dragging files and 
directories. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FS_DIRECT_SELECT_BY_DOUBLE_CLICK: If this option is set and the user 
double-click on a file it will have the same meaning as single 
click + click on the OK button (i.e. the expected behaviour). \par \pard \li1200 \pard \li1200 \pard \li1200 
NOTE! this option will automatically set the option FS_NO_DRAG_DROP 
since these two can not coexist. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FS_SAVE_AS: Makes the file selector beahave slightly different 
from the default. Currently the only difference is that a name 
entered by the user (typed or selected) will not be rubbed from the 
selection field when changing directory. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FS_SHOW_DIR_TREE: Will show the directory tree in a separate view 
to the left of the list with selectable files. If this flag is set 
then there will be no directories displayed in the file list unless 
you also set `FS_SHOW_DIRS_IN_FILE_VIEW'. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FS_SHOW_DIRS_IN_FILE_VIEW: You only need to use this flag in case 
you use a separate directory view (i.e. use the flag 
`FS_SHOW_DIR_TREE'), because otherwise it will be the default 
setting. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FS_HIDE_LOCATION: By default there is a location field showing the 
full path to the currently selected directory to the user. In case 
you don't like this you can avoid it by setting this flag. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FS_HIDE_UP_BUTTON: By default there is a button that let the user 
change to the directory "above" the current. In case a directory 
tree is shown this may seem redundant. If the ".." directory is 
present in the file list it is also redundant. Use this flag to 
skip the button. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FS_HIDE_UP_DIRECTORY: By default the up-directory (i.e. "..") is 
displayed in the file list (however not in case directories are 
hidden because `FS_SHOW_DIR_TREE' is set). Use this flag to skip 
that line. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FS_FILE_FILTER_IS_READ_ONLY: The edit-box showing the masks will 
be disabled for user input. 
\par}\pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  winheader: A string that will be used as header of the browser 
window. If you pass the empty string, a default text will be used. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  buttonlabel: A string that will be used as label of the confirm 
button. If you pass the empty string, a default text will be used. 
\par}\pard \li400 \pard \li400 \par Note! The implementation of the browser is a list, and by default lists 
get an event for SINGLE CLICK. In the browser the user can double-click 
to select a certain file or directory directly (this is a common 
behaviour of bowsers). However, what will happen if doubel-clicking on 
e.g. a directory for opening it? If the drag-drop is active it will in 
most cases be seen as a try to grip the object and therby it will be 
inserted into the copy-buffer. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b char *{\xe\v UnPackSelection}UnPackSelection(char **flist)\par }
{\li400 This function may be used to unpack individual filenames (including path) 
from the return string of `FileSelect'. 
The return value points to the first file of *flist and is dynamic memory 
and it is your responsibility to free it. *flist will be advanced to next 
file and will point to the string end when no more files. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v FileManager}FileManager(const char *winheader, int flags);\par }
{\li400 Creates a dialogue that lets the user inspect and maintain the 
file system. 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  Files and directories may be deleted and copied in the file list, 
either by use of hot-keys, menu-selection or drag-and-drop. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  Directories may be created in the file list. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  The contents of the file list to display may be configured by the user. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  The size of many window objects may be configured by the user. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  There are special copy features, allowing the user to walk around 
and marking files in the file list for copying and also the possibility 
to display the current set of files marked for copying. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  I is possible for the user to start new file-managers that can 
used for e.g. drag-and-drop. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  The possibility of multiple file-masks. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  The user may edit the name and attributes of files and directories. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  Modifications of the various window settings and feature modes made 
by the user will be stored in the current config file, and are 
retrieved next time a file-manager is opened. Specially the current 
directory will be stored. 
\par}\pard \li400 \pard \li400 \pard \li400 \pard \li400 \pard \li400 \pard \li400 \pard \li400 \pard \li400 \pard \li400 \par Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  winheader: A string used as header of the browser window. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  flags: The flags variable control some of the properties of the 
browser. Thier names and meaning is as follows: 
\par {\li1200 \pard \li1200 \pard \li1200 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FM_BROWSE_DAT: Will display Allegro's datafiles as directories 
and lets the user browse them as if they actually where 
directories. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FM_DISABLE_EDIT_DAT: Set this flag if you allow the user to 
browse datafiles but not want him/her to change them. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FM_DISABLE_CREATE_DIR: Don't let the user create directories. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FM_DISABLE_DELETING: Don't let the user delete files or 
directories. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FM_DISABLE_COPYING: Don't let the user copy files or directories. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FM_DO_NOT_SHOW_MENU: By default a menu is created (See 
FileBrowse about the contents). This flag suppresses the default. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FM_NO_SETTINGS_IN_CONFIG: By default the browser retrievs the 
previous user configuration from the current config-file (and 
stores the new one when closing). Use this flag to suppresses this 
behaviour. The data concerned are: 
\par {\li1600 \pard \li1600 \pard \li1600 \pard \li1600 \pard \li1600 \pard \li1600 \pard \li1600 \pard \li1600 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  The path to use when opening. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  Flag telling if the image of an image file or object shall be 
displayed. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  Flag telling if the original file name of a data-file object 
shall be displayed. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  Flag telling if file time shall be displayed. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  Flag telling if file size shall be displayed. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  Flag telling if file attributes shall be displayed. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  Flag telling if hidden/system file shall be displayed. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  Flag telling if formatted case of file-names shall be 
displayed. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  The width of each column in the file-list of the browser. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  The width of the file-list of the browser. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  The height of the file-list of the browser. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  The window position. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  A flag indication if the copy-buffer was opened last time. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  A flag indication if the copy-buffer is in add-mode or not. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  The status field width. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600  The sorting criterias. 
\par}\pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \pard \li1200 \par The settings for the file-manager is separated from those of 
the file-selector. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FM_SHOW_DIR_TREE: Will show the directory tree in a separate view 
to the left of the file list. If this flag is set then there will be 
no directories displayed in the file list unless you also set 
`FM_SHOW_DIRS_IN_FILE_VIEW'. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FM_SHOW_DIRS_IN_FILE_VIEW: You only need to use this flag in case 
you use a separate directory view (i.e. use the flag 
`FM_SHOW_DIR_TREE'), because otherwise it will be the default 
setting. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FM_HIDE_FILE_VEW: If this flag is used the file view will not be 
displayed at all (which makes the flags concerning the file view 
useless). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FM_HIDE_UP_BUTTON: By default there is a button that let the user 
change to the directory "above" the current. In case a directory 
tree is shown this may seem redundant. If the ".." directory is 
present in the file list it is also redundant. Use this flag to 
skip the button. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FM_HIDE_UP_DIRECTORY: By default the up-directory (i.e. "..") is 
displayed in the file list (however not in case directories are 
hidden because `FM_SHOW_DIR_TREE' is set). Use this flag to skip 
that line. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  FM_NO_FLOATING: This will force the browsing window to be modal. 
(by default it is a floating window). 
\par}\par}\pard \li400 \pard \li400 \pard \li400 \pard \li400 \pard \li400 \pard \li400 \pard \li400 \par}\par \par \par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v RegisterFileType}RegisterFileType(const char *ext, void (*Handler)(void *privatedata, char *path), void *privatedata, const char *actionname, const char *icon, const char *typetext, void (*Viewer)(void *privatedata, void *viewdata));\par }
{\li400 \par \par This function will register a file type so that the file-browser 
will identify it and give it some special handling. There are three 
things that can be done: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  Assign an icon to that file type (to be displayed in the browser). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  Assign a name to that file type (to be displayed in the inspect/edit 
dialogue). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  Assign a call-back function to that file type. This will give the 
user the opportunity to perform some action with such files 
as input. Optionally you can pass a name for the action. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  Assign a pre-viewer for that file type. 
\par}\pard \li400 \pard \li400 \pard \li400 \pard \li400 \par If e.g. you only want to register an icon or name just pass NULL for the 
data and call-back parameters.\par 
The registration will be reflected both in the file-selector and the 
file-manager concerning icon and info. The action registration will 
however only have effect in the file-manager.\par 
All registering is global, i.e. if the browser is used in different 
contexts they will be present at all of them. You can disable a 
registration by calling with all parameters set to NULL.\par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  ext: The file extension to register e.g. "txt" for "*.txt" 
files. 
Note: this is not the usual "file-mask". Only the substring following 
a possible '.' in the filename must be passed and it must also be a 
distinct string - no wildcards. 
If you alternativly want to make a registration for a datfile object 
type, just pass the name of the data-object type prefixed by a '#', 
e.g. like "#RLE" for rle sprites. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  Handler: The name of a function to be called when the user selects a 
file of this type (i.e. click with the right mouse button and selects 
"action name"). The call-back will be executed without closing the 
fila-manager dialogue.\par \pard \li800 \pard \li800 
`Handler' takes the following parameters: 
\par {\li1200 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  data: A pointer to any data (this will be the same value as 
previously passed to `RegisterFileType'). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  path: The path and filename that was selected. 
\par}\pard \li800 \pard \li800 \pard \li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  privatedata: A pointer to any data. It will be passed to `Handler' 
and `Viewer' when called. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  actionname: An optional  string that specifies the action for the 
user, (e.g. "Edit" or "Execute"). The action-name will e.g. be 
displayed in the drop-down menu where the action is executed. If 
omitted the default text will be "Action". 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  icon: An icon that the browser will show to the left of any file 
of this type. If you want the icon to be displayed properly without 
clipping: keep the size within 22x16. The icon must have been loaded 
globally with the CGUI-function `CguiLoadImage' prior to the registration. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  typetext: A string that tells the user what type of file this is 
(i.e. as an alternative to the icon, but may possibly be more 
exhaustive). 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  Viewer: A function that understands files of type `ext'. It will be 
called when the file browser is about to view the content of a file. 
This may be done in some different contexts depending on what the user 
does (which can be restricted by your settings) and which options the 
user has set (which availibility for modification can also be 
restriced by your settings). E.g. in the inspect/edit dialogue of file 
object and in the pre-view.\par \pard \li800 \pard \li800 \pard \li800 \pard \li800 \pard \li800 
`Viewer' shall take two parameters. The first one is your `privatedata' 
and the second is: 
\par {\li1200 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  if `ext' defines an file extension then viewdata is the fullpath 
name to the a file of type `ext'. 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200  if `ext' defines a data-file type the viewdata is a pointer to 
a datafile object. 
\par}\pard \li800 \pard \li800 \pard \li800 \par `Viewer' is supposed to add some object that displays the content of 
the file in a some way. 
\par}\par Pass an empty string for those parameters not used. 
Pass NULL-pointers for call-backs you don't need.\par 
Returns 0 if fail (ext is empty) else non-zero. 
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Mouse-cursors}Mouse-cursors\par }
You should not use the Allegro functions/variables for mouse-manipulations 
directly. CGUI will do some changes for certain events, that will override 
such changes. Instead use the functions listed below. There are some pre- 
defined cursors "installed" that you can selecet among (CGUI uses them 
itself). You may also extend this list of installed cursors. In addition to 
this you may create overlayed cursors, i.e. make a new cursor from the 
currently selected and some other sprite. 
\par \par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v cgui_mouse_draw_in_interrupt}cgui_mouse_draw_in_interrupt;\par }
{\li400 A global variable that tells the mouse cursor to be drawn inside the 
interrupt. The default is not. The reason why the mouse is drawn "polled" 
(or rather via the event queue), is that the interrupt drawing will not 
draw well if you use canvases. This is a weakness in CGUI, that may be 
removed in later versions. The reason why uou want to let the cursor to 
be drawn in the interrupt is that it otherwise will "freeze" if the 
program is busy for a long time without returning the control to the 
event queue processor (this is quite rare in most programs, e.g. disk 
accesses for 1M will not be affect the mouse moving). 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v InstallCursor}InstallCursor(int cursor_no, BITMAP *sprite, int x, int y);\par }
{\li400 Installs a sprite to be a predefined cursor. This cursor may replace an 
existing cursor, as well as extend the list of available. x,y is the 
hotspot point relative to the upper left corner of the sprite. 
InstallCursor will make a copy of the bitmap, so you are still 
responsible for the memory after the call, and may feel free to destroy 
it.\par 
If your cursor replaces an existing one, the latter will be destroyed. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v SelectCursor}SelectCursor(int cursor_no);\par }
{\li400 Selects a predefined cursor using the specified index. 
Available cursor alternatives are: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  CURS_DEFAULT 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  CURS_DRAGGABLE 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  CURS_ILLEGAL 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  CURS_BUSY 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  CURS_DRAG_H 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  CURS_DRAG_V 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  CURS_CROSS 
\par}\pard \li400 \pard \li400 \pard \li400 \pard \li400 \pard \li400 \pard \li400 \pard \li400 \par The mouse event processing will occasionally switch between the above 
indexes. E.g. moving over a draggable object will set CURS_DRAGGABLE. If 
you select another index this will inhibit this automatic cursor 
switching.\par 
Selecting another cursor than above requires that the cursor have been 
installed first. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v PointerLocation}PointerLocation(int id, int *x, int *y);\par }
{\li400 Returns the mouse pointer locataion related to the specified object. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b BITMAP *{\xe\v ObjectApearance}ObjectApearance(int id);\par }
{\li400 Returns a pointer to a bitmap showing the current view of the specified 
object. The bitmap belongs to you, i.e. it's your responsibility to destroy 
it when you don't need it any longer. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v OverlayPointer}OverlayPointer(BITMAP *sprite, int x, int y);\par }
{\li400 Creates an overlayed mouse pointer. This means that a new pointer will 
be created by merging the appearances of `sprite' and the current selected 
pointer.\par 
The current selected pointer will appear on top of `sprite'.\par 
Overlayed mouse pointer may be useful e.g. during dragging operations 
showing the dragged object as a cursor and letting the current selected 
cursor still be left on top to point out the "hot spot".\par 
The current selected cursor can later be restored as a single pointer 
by `RemoveOverlayPointer'.\par 
Subsequent calls to `OverlayPointer' let you overlay multiple cursors.\par 
If `SelectCursor' is called while an overlayed pointer is in use 
the requested change will be reflected in the overlayed pointer.\par 
Parameters: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  sprite: a pointer to a sprite. This may be destroyed after the call 
{\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800  x,y: specifies the offset from top-left corner of your sprite to 
the hotspot. 
\par}\par}\pard \li0 \pard \li0 \par \par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v RemoveOverlayPointer}RemoveOverlayPointer(void);\par }
{\li400 UnInstalles a secondary cursor previously installed by OverlayPointer. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v MkTextPointer}MkTextPointer(FONT *f, char *text);\par }
{\li400 \par \par Creates an overlayed cursor using the specified text and font 
Restore a plain pointer by a call to `RemoveOverlayPointer'. 
\par \par \par \par \par \par \par \par \par \par }
