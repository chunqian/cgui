/* LOADTEXT.C
   Contains all functions that are needed for loading language specific
   texts generated by the tool mktext. See tools/readme.txt for details */
#include <string.h>
#include <ctype.h>

#include <allegro.h>

#include "cgui.h"
#include "cgui/mem.h"
#include "cguiinit.h"
#include "loadtext.h"

#define MAXNAME 1000

#if (ALLEGRO_SUB_VERSION < 2) || ((ALLEGRO_SUB_VERSION == 2) && (ALLEGRO_WIP_VERSION == 0))
#define file_size_ex file_size
#endif

typedef struct t_section {
   char *name;
   const char *const*start;
   int i;
   int rows;
} t_section;

typedef struct t_txtfile {
   char *fn;
   char *lang;
   char *text;
   const DATAFILE *dat;
   char **txt;
   int rows;
   struct t_txtfile *next;
   int ns;
   t_section *sec;
} t_txtfile;

typedef struct t_converter {
   void *data;
   char *name;
   void (*Handler)(void *, char *);
} t_converter;

static t_converter *converter = NULL;
static int nr_converters;

static t_txtfile *tf = NULL;

static char *GetLanguage(void)
{
   static char langtxt[20];
   const char *lang;

   lang = get_config_string("cgui", "language", "");
   if (*lang == 0) {
      lang = get_config_string("system", "language", "en");
      if (*lang == 0)
         lang = "en";
   }
   strcpy(langtxt, lang);
   return langtxt;
}

#ifndef ALLEGRO_DOS
#ifndef ALLEGRO_WINDOWS
static int strnicmp(const char *s1, const char *s2, int n)
{
   int i;
   for (i=0; i<n && *s1 && *s2; s1++, s2++, i++)
      if (tolower(*s1)!=tolower(*s2))
         return tolower(*s1) - tolower(*s2);
   return 0;
}
#endif
#endif

static void GetLanguagePart(char *s, int n, char *lang, int *start, int *end)
{
   int len, i;

   len = strlen(lang);
   *start = -1;
   *end = n;
   for (i = 0; i < n; i++) {
      if (s[i] == '<') {
         if (i < 1 || s[i-1] == '\n' || s[i-1] == '\r') {
            if (*start > -1) {
               *end = i;
               break;
            } else if (strncmp(s + i + 1, lang, len) == 0) {
               if (s[i + len + 1] == '>' || *lang == 0) {
                  while (s[i] != '>') {
                     i++;
                  }
                  i++;
                  while (isspace(s[i]) && i < n)
                     i++;
                  *start = i;
               }
            }
         }
      }
   }
}

static void SetSecData(t_section *sec, char **ps, int i)
{
   sec->start = (const char*const*)ps + sec->i;
   sec->rows = i - sec->i;
}

static t_section *AddSection(char *name, int startrow, t_txtfile *t)
{
   t_section *sec;

   t->ns++;
   t->sec = ResizeMem(t_section, t->sec, t->ns);
   sec = t->sec + t->ns - 1;
   sec->name = name;
   sec->i = startrow;
   return sec;
}

/* Select the desired language part */
static char *FindLanguageSection(t_txtfile *t, char *rawtext, int size, int *langsize)
{
   char errstr[10000];
   int langstart, langend;

   GetLanguagePart(rawtext, size, t->lang, &langstart, &langend);
   if (langstart == -1) {
      GetLanguagePart(rawtext, size, "en", &langstart, &langend);
      if (langstart == -1) {
         GetLanguagePart(rawtext, size, "", &langstart, &langend);
         if (langstart == -1) {
            sprintf(errstr, "Requested textfile contains no language");
            StartUpError(t->fn, errstr);
            langstart = langend;
         }
      }
   }
   *langsize = langend - langstart;
   return rawtext + langstart;
}

static void CreateRows(t_txtfile *t, int size)
{
   char **ps;
   char *s, *end;
   int i, rows;
   t_section *sec;

   /* Replace all carrage return and linefeeds with eos, and count rows */
   for (s=t->text, end = t->text + size + 1, rows = 0; s < end;) {
      if (*s == '\r') {
         *s++ = 0;
         rows++;
         if (*s == '\n')
            *s++ = 0;
      } else if (*s == '\n') {
         *s++ = 0;
         rows++;
         if (*s == '\r')
            *s++ = 0;
      } else
         s++;
   }

   /* Set up a pointer array and partition into sections
      - one pointer to each individual text (row) */
   ps = GetMem(char *, rows);
   t->txt = ps;
   for (i = 0, sec = NULL, s = t->text; i < rows;) {
      if (*s == '\"') {
         ps[i++] = s + 1;
      } else if (*s == '[') {
         if (sec)
            SetSecData(sec, ps, i);
         i++;
         sec = AddSection(s + 1, i, t);
      } else {
         ; /* Unknown row-type */
      }
      while (*s)
         s++;
      while (*s == 0)
         s++;
   }
   if (sec)
      SetSecData(sec, ps, i);
   t->rows = rows;
}

static const char *const*SelectTextSection(t_txtfile *t, const char *sect, int *nr)
{
   char errstr[200];
   int i, diff, start, end;
   t_section *s;

   s = t->sec;
   *nr = 0;
   if (s == NULL)
      return NULL;
   start = 0;
   end = t->ns;
   i = end / 2;
   do {
      if (*sect == *s[i].name) {
         do {
            diff = strcmp(sect, s[i].name);
            if (diff == 0) {
               *nr = s[i].rows;
               return s[i].start;
            } else {
               if (diff < 0)
                  end = i;
               else
                  start = i + 1;
               i = (start + end) >> 1;
            }
         } while (end > start);
      } else {
         if (*sect < *s[i].name)
            end = i;
         else
            start = i + 1;
         i = (start + end) >> 1;
      }
   } while (end > start);

   sprintf(errstr, "Section '%s' was not found in textfile", sect);
   StartUpError(errstr, t->fn);
   return NULL;
}

static void FreeText(t_txtfile *t)
{
   Release((void*)t->txt);
   Release(t->text);
   Release(t->lang);
   if (t->fn)
      Release(t->fn);
   Release(t->sec);
   Release(t);
}

static void DestroyTexts2(t_txtfile *t)
{
   if (t) {
      DestroyTexts2(t->next);
      FreeText(t);
   }
}

extern void DestroyTexts(void)
{
   if (tf) {
      DestroyTexts2(tf);
      tf = NULL;
   }
}

extern void DeInitTexts(void *data nouse)
{
   DestroyTexts();
}

static t_txtfile *CreateTextLink(char *lang)
{
   t_txtfile *t;

   if (tf == NULL)
      HookCguiDeInit(DeInitTexts, NULL);
   t = GetMem0(t_txtfile, 1);
   t->next = tf;
   tf = t;
   t->lang = MkString(lang);
   return t;
}

static void DestroyTextLink(t_txtfile *t)
{
   t_txtfile *p;

   if (t == tf) {
      tf = tf->next;
      FreeText(t);
   } else {
      for (p = tf; p->next && p->next != t; p = p->next)
         ;
      if (p->next) {
         p->next = t->next;
         FreeText(t);
      }
   }
}

static int LoadTextsFromFile(t_txtfile *t, char **rawtext)
{
   int nr_read = 0;
   PACKFILE *file;
   int ok = 1;

   nr_read = file_size_ex(t->fn);
   file = pack_fopen(t->fn, "rb");
   if (file == NULL) {
      ok = 0;
      StartUpError(t->fn, "No textfile found");
   } else {
      /* Load the entire file in one chunk */
      *rawtext = GetMem(char, nr_read);

      nr_read = pack_fread(*rawtext, nr_read, file);
      pack_fclose(file);
   }
   return nr_read;
}

extern const char *const*LoadTexts(const char *fn, const char *sect, int *nr)
{
   t_txtfile *t;
   char *langtext, *rawtext=NULL;
   int size, langsize;

   langtext = GetLanguage();
   /* Check if file is already loaded */
   for (t = tf; t; t = t->next) {
      if (strcmp(t->fn, fn) == 0) {
         if (strcmp(t->lang, langtext) == 0)
            break;
         else { /* It is a new language */
            DestroyTextLink(t);
            t = NULL;
            break;
         }
      }
   }
   if (t == NULL) {
      /* If not then load the entire file (all sections within it will be
         present not only the currently requested one) */
      t = CreateTextLink(langtext);
      t->fn = MkString(fn);
      size = LoadTextsFromFile(t, &rawtext);
      langtext = FindLanguageSection(t, rawtext, size, &langsize);
      t->text = GetMem(char, langsize + 1);
      t->text[langsize] = 0;
      memmove(t->text, langtext, langsize);
      Release(rawtext);
      CreateRows(t, langsize);
   }
   /* Look for the requested section */
   return SelectTextSection(t, sect, nr);
}

extern const char *const*LoadCompiledTexts(const DATAFILE *dat, const char *sect, int *nr)
{
   t_txtfile *t;
   char *langtext, *rawtext;
   int langsize, utf8_size;

   langtext = GetLanguage();

   /* Check if file is already initialized */
   for (t = tf; t; t = t->next) {
      if (t->dat == dat) {
         if (strcmp(t->lang, langtext) == 0)
            break;
         else { /* It is a new language */
            DestroyTextLink(t);
            t = NULL;
            break;
         }
      }
   }
   if (t == NULL) {
      t = CreateTextLink(langtext);
      t->dat = dat;
      t->fn = strdup("");

      // fromtype, newtype
      if (_cgui_utf8_format_is_requested) {
         utf8_size = uconvert_size(dat->dat, U_ASCII, U_CURRENT);
         rawtext = GetMem(char, utf8_size);
         uconvert(dat->dat, U_ASCII, rawtext, U_CURRENT, utf8_size);
      } else {
         rawtext = MkString(dat->dat);
      }

      langtext = FindLanguageSection(t, rawtext, dat->size, &langsize);
      t->text = GetMem(char, langsize + 2);
      t->text[langsize] = 0;
      t->text[langsize+1] = 'x';
      memmove(t->text, langtext, langsize);
      CreateRows(t, langsize);
      Release(rawtext);
   }
   /* Look for the requested section */
   return SelectTextSection(t, sect, nr);
}

static void DestroyConversionHandlers(void *data nouse)
{
   int i;

   for (i=0; i < nr_converters; i++)
      Release(converter[i].name);
   Release(converter);
}

extern void RegisterConversionHandler(void (*Handler)(void *, char *), void *data, const char *name)
{
   if (converter == NULL)
      HookCguiDeInit(DestroyConversionHandlers, NULL);
   nr_converters++;
   converter = ResizeMem(t_converter, converter, nr_converters);
   converter[nr_converters - 1].Handler = Handler;
   converter[nr_converters - 1].data = data;
   converter[nr_converters - 1].name = MkString(name);
}

extern void PrintFloatingConversion(char *d, const char *s)
{
   const char *start;
   int i;

   for (; *s; s++) {
      if (*s == '%' && *(s + 1) == '<') {
         for (start = ++s; *s && *s != '>'; s++)
            ;
         for (i=0; i < nr_converters; i++) {
            if (strnicmp(converter[i].name, start, MIN(s - start, MAXNAME)) == 0) {
               if (converter[i].Handler)
                  converter[i].Handler(converter[i].data, d);
                  d += strlen(d);
               break;
            }
         }
      } else {
         *d++ = *s++;
      }
   }
   *d = 0;
}
